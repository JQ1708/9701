<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Atomic Structure Interactive Notes</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Oswald:wght@500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .header-font { font-family: 'Oswald', sans-serif; }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    .animate-fade-in-up { animation: fadeInUp 0.5s ease-out forwards; }
    .animate-fade-in { animation: fadeInUp 0.8s ease-out forwards; }
    .animate-spin-slow { animation: spin 20s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .key-bold { font-weight: 700; color: #0f172a; }
    .key-italic { font-style: italic; color: #0369a1; }
    .key-circle { border: 2px solid #f97316; border-radius: 9999px; padding: 0 8px; display: inline-block; white-space: nowrap; color: #c2410c; font-weight: bold; font-size: 0.9em; }
    .key-underline { text-decoration: underline; text-decoration-color: #be185d; text-decoration-thickness: 3px; }
    .key-highlight { background-color: #fef08a; padding: 0 4px; border-radius: 2px; }
    .key-float { display: inline-block; animation: float 3s ease-in-out infinite; color: #6366f1; font-weight: bold; }
    @keyframes float { 0% { transform: translateY(0px); } 50% { transform: translateY(-3px); } 100% { transform: translateY(0px); } }
  </style>
</head>
<body class="bg-slate-100">
  <div id="root"></div>

  <template id="model-structure-atom" data-source="1. Structure of Atom.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atom Structure: Empty Space & Attraction</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #ffffff; /* White background to match the paper diagram */
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #f5f7fa 0%, #c3cfe2 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #4a90e2;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            color: #2c3e50;
        }
        
        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #555;
            margin-bottom: 15px;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toggle-btn {
            background: #eef2f7;
            border: 1px solid #d1d9e6;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            color: #4a90e2;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .toggle-btn:hover {
            background: #e1e7f0;
        }
        .toggle-btn.active {
            background: #4a90e2;
            color: white;
            border-color: #357abd;
        }

        /* Floating Labels */
        .label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }
        
        .annotation-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #4a90e2;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.2s;
            z-index: 10;
        }
        .annotation-marker:hover {
            transform: scale(1.2);
            background: #357abd;
        }

        /* Popups for annotations */
        .popup {
            position: absolute;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            width: 200px;
            display: none;
            z-index: 20;
            font-size: 0.9rem;
            border: 1px solid #eee;
        }
        .popup::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 12px;
            height: 12px;
            background: white;
            border-right: 1px solid #eee;
            border-bottom: 1px solid #eee;
        }
        .popup strong {
            display: block;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        
        .close-popup {
            position: absolute;
            top: 5px;
            right: 8px;
            cursor: pointer;
            color: #999;
            font-size: 16px;
        }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    
    <!-- Floating Labels (Managed by JS) -->
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>Atom Structure</h1>
            <p>Based on the Rutherford model. Observe the empty space and orbital paths.</p>
            
            <div class="controls">
                <button class="toggle-btn active" id="btn-orbit" onclick="toggleAnimation()">
                    <span>Orbit Animation</span> <span>‚ñ∂</span>
                </button>
                <button class="toggle-btn" id="btn-attract" onclick="toggleAttraction()">
                    <span>Show Attraction</span> <span>üëÅ</span>
                </button>
            </div>

            <div style="margin-top: 20px; font-size: 0.8rem; color: #666; border-top: 1px solid #eee; padding-top: 10px;">
                <strong>Key Concepts:</strong>
                <ul style="padding-left: 20px; margin: 5px 0;">
                    <li>Nucleus: Protons (+) & Neutrons</li>
                    <li>Electrons: Negative (-) charge</li>
                    <li>Structure: Mainly empty space</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Popup Template -->
    <div id="popup-template" class="popup">
        <span class="close-popup" onclick="hidePopups()">√ó</span>
        <strong class="popup-title">Title</strong>
        <span class="popup-content">Content</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();
        // Soft white fog for depth
        scene.fog = new THREE.FogExp2(0xeef2f5, 0.02);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- Materials ---
        const matProton = new THREE.MeshPhysicalMaterial({ color: 0xff4d4d, roughness: 0.4, metalness: 0.1, clearcoat: 1 }); // Red
        const matNeutron = new THREE.MeshPhysicalMaterial({ color: 0x4d94ff, roughness: 0.4, metalness: 0.1, clearcoat: 1 }); // Blue
        const matElectron = new THREE.MeshStandardMaterial({ color: 0x2980b9, emissive: 0x2980b9, emissiveIntensity: 0.4 }); // Darker Blue
        const matOrbit = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2 });
        const matAttraction = new THREE.LineDashedMaterial({ color: 0xffa502, dashSize: 0.2, gapSize: 0.1, opacity: 0.8, transparent: true });

        // --- Geometry ---
        const sphereGeo = new THREE.SphereGeometry(1, 32, 32);

        // --- Objects ---
        const nucleusGroup = new THREE.Group();
        scene.add(nucleusGroup);
        
        const electrons = [];
        const attractionLines = [];

        // 1. Build Nucleus (Cluster)
        // Creating a small cluster of red (proton) and blue (neutron) spheres
        const nucleusConfig = [
            {x:0.3, y:0.3, z:0, type:'p'}, {x:-0.3, y:-0.3, z:0, type:'n'},
            {x:0.3, y:-0.3, z:0.3, type:'n'}, {x:-0.3, y:0.3, z:-0.3, type:'p'},
            {x:0, y:0, z:0.5, type:'p'}, {x:0, y:0, z:-0.5, type:'n'}
        ];

        nucleusConfig.forEach(p => {
            const mesh = new THREE.Mesh(sphereGeo, p.type === 'p' ? matProton : matNeutron);
            mesh.scale.set(0.4, 0.4, 0.4);
            mesh.position.set(p.x, p.y, p.z);
            nucleusGroup.add(mesh);
        });

        // 2. Build Orbits & Electrons
        // We want 3 crossing elliptical orbits
        
        function createOrbitSystem(rotX, rotY, rotZ, radiusX, radiusY, speedOffset) {
            const orbitGroup = new THREE.Group();
            orbitGroup.rotation.set(rotX, rotY, rotZ);
            scene.add(orbitGroup);

            // Draw Orbit Path
            const curve = new THREE.EllipseCurve(0, 0, radiusX, radiusY, 0, 2 * Math.PI, false, 0);
            const points = curve.getPoints(100);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const orbitLine = new THREE.Line(geometry, matOrbit);
            orbitGroup.add(orbitLine);

            // Create Electron
            const electron = new THREE.Mesh(sphereGeo, matElectron);
            electron.scale.set(0.25, 0.25, 0.25);
            orbitGroup.add(electron);

            // Store data for animation
            electrons.push({
                mesh: electron,
                curve: curve,
                speed: 0.5 + Math.random() * 0.5, // Random speed
                pos: Math.random(), // Random start position (0-1)
                group: orbitGroup // Reference to parent for world position calc
            });
        }

        // Create 3 Crossing Orbits (simulating the diagram)
        createOrbitSystem(Math.PI/3, 0, 0, 6, 4);    // Tilted X
        createOrbitSystem(-Math.PI/3, 0, 0, 6, 4);   // Tilted X opposite
        createOrbitSystem(Math.PI/2, Math.PI/2, 0, 4, 7); // Vertical-ish

        // 3. Attraction Lines (Dynamic)
        // We create a line for each electron connecting to center
        electrons.forEach(e => {
            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
            const line = new THREE.Line(geometry, matAttraction);
            line.visible = false; // Hidden by default
            line.computeLineDistances(); // Important for dashed lines
            scene.add(line);
            attractionLines.push({ line: line, electronRef: e });
        });


        // --- Annotations (HTML Markers) ---
        const markers = [
            { pos: new THREE.Vector3(0, 0, 0), title: "The Nucleus", content: "Mass is concentrated here. Made of Protons (+) and Neutrons (0)." },
            { pos: new THREE.Vector3(5, 4, 0), title: "Mainly Empty Space", content: "The volume of the atom is mostly empty space between the nucleus and electrons." },
            { pos: new THREE.Vector3(-4, -4, 0), title: "Electron Orbit", content: "Electrons (-) orbit rapidly. They are attracted to the positive nucleus." }
        ];

        markers.forEach((m, index) => {
            const el = document.createElement('div');
            el.className = 'annotation-marker';
            el.innerText = index + 1;
            el.onclick = (e) => showPopup(e, m.title, m.content);
            labelsContainer.appendChild(el);
            m.element = el;
        });

        const popup = document.getElementById('popup-template');

        window.showPopup = function(e, title, content) {
            e.stopPropagation();
            popup.querySelector('.popup-title').innerText = title;
            popup.querySelector('.popup-content').innerText = content;
            popup.style.display = 'block';
            
            // Position popup near the click
            // Basic positioning logic
            const rect = e.target.getBoundingClientRect();
            popup.style.left = (rect.left + rect.width/2 - 100) + 'px'; // Center horizontally
            popup.style.top = (rect.top - 100) + 'px'; // Above marker
        };

        window.hidePopups = function() {
            popup.style.display = 'none';
        };
        
        // Hide popup when clicking background
        document.addEventListener('click', (e) => {
            if(!e.target.closest('.annotation-marker')) hidePopups();
        });


        // --- Logic & Animation ---
        let isAnimating = true;
        let showAttraction = false;

        window.toggleAnimation = function() {
            isAnimating = !isAnimating;
            document.getElementById('btn-orbit').classList.toggle('active');
        };

        window.toggleAttraction = function() {
            showAttraction = !showAttraction;
            document.getElementById('btn-attract').classList.toggle('active');
            attractionLines.forEach(item => {
                item.line.visible = showAttraction;
            });
        };

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.001;

            // 1. Animate Electrons
            if (isAnimating) {
                electrons.forEach(e => {
                    // Update progress along curve
                    e.pos = (e.pos + (0.005 * e.speed)) % 1;
                    const point = e.curve.getPoint(e.pos);
                    e.mesh.position.set(point.x, point.y, 0); // Local position in orbit group
                });
            }

            // 2. Update Attraction Lines
            if (showAttraction) {
                attractionLines.forEach(item => {
                    const eMesh = item.electronRef.mesh;
                    const eGroup = item.electronRef.group;
                    
                    // Get World Position of Electron
                    const worldPos = new THREE.Vector3();
                    eMesh.getWorldPosition(worldPos);

                    // Update Line Geometry
                    const positions = item.line.geometry.attributes.position.array;
                    // Point 0 is always center (0,0,0) - Nucleus
                    positions[0] = 0; positions[1] = 0; positions[2] = 0;
                    // Point 1 is Electron
                    positions[3] = worldPos.x; positions[4] = worldPos.y; positions[5] = worldPos.z;
                    
                    item.line.geometry.attributes.position.needsUpdate = true;
                    item.line.computeLineDistances(); // Re-calc dashes
                });
            }

            // 3. Update Markers Position (3D to 2D)
            markers.forEach(m => {
                // Clone position so we don't modify original
                const tempV = m.pos.clone();
                
                // If marker is meant to track an object (optional), update tempV here
                // For static markers in space, just project
                
                tempV.project(camera);

                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                // Hide if behind camera
                if(tempV.z > 1) {
                    m.element.style.display = 'none';
                } else {
                    m.element.style.display = 'flex';
                    m.element.style.left = x + 'px';
                    m.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
  </template>

  <template id="model-shells-subshells" data-source="1. Shells & Sub-shells.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shells, Sub-shells, and Orbitals</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #f4f7f6 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #0984e3; /* Blue for Shell */
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            color: #2c3e50;
        }
        
        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #555;
            margin-bottom: 10px;
        }

        .legend {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .line-indicator {
            width: 30px;
            height: 4px;
            margin-right: 10px;
            border-radius: 2px;
        }

        /* 3D Labels */
        .label {
            position: absolute;
            background: rgba(255,255,255,0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: bold;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: translate(-50%, -50%);
            transition: opacity 0.2s;
            opacity: 0.8;
        }
        .label:hover { opacity: 1; z-index: 10; }

        /* Highlight classes for interactivity */
        .highlight-text {
            color: #d63031;
            font-weight: bold;
        }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>Atomic Hierarchy</h1>
            <p>Visualizing the relationship between Shells, Sub-shells, and Orbitals (n=2).</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="line-indicator" style="background: #0984e3;"></div>
                    <span>Shell (n=2)</span>
                </div>
                <div class="legend-item">
                    <div class="line-indicator" style="background: #e17055;"></div>
                    <span>Sub-shell (s & p)</span>
                </div>
                <div class="legend-item">
                    <div class="line-indicator" style="background: #00b894;"></div>
                    <span>Orbitals</span>
                </div>
            </div>
            
            <p style="margin-top: 20px; font-size: 0.8rem; color: #888;">
                Hover over elements to see their grouping.
            </p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Configuration ---
        const COLORS = {
            shell: 0x0984e3,     // Blue
            subshell: 0xe17055,  // Red
            orbital: 0x00b894,   // Green
            highlight: 0xffea00
        };

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 15, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 0);

        // --- Lights ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- Geometry Helpers ---
        
        // 1. Orbital Geometries
        const sphereGeo = new THREE.SphereGeometry(1.2, 32, 32);
        
        function createDumbbell() {
            const group = new THREE.Group();
            const lobeGeo = new THREE.SphereGeometry(1, 32, 32);
            lobeGeo.scale(1, 1.8, 1); // Stretch
            
            const topLobe = new THREE.Mesh(lobeGeo, new THREE.MeshStandardMaterial({ color: COLORS.orbital, roughness: 0.3, metalness: 0.1 }));
            topLobe.position.y = 1;
            
            const bottomLobe = new THREE.Mesh(lobeGeo, new THREE.MeshStandardMaterial({ color: COLORS.orbital, roughness: 0.3, metalness: 0.1 }));
            bottomLobe.position.y = -1;
            
            group.add(topLobe, bottomLobe);
            return group;
        }

        // 2. Boundary Rings (Shell/Subshell lines)
        function createRing(radiusX, radiusZ, color, thickness=0.05) {
            // Using a TubeGeometry to make a custom ellipse path
            const curve = new THREE.EllipseCurve(
                0, 0,            // ax, aY
                radiusX, radiusZ, // xRadius, yRadius
                0, 2 * Math.PI,  // aStartAngle, aEndAngle
                false,           // aClockwise
                0                // aRotation
            );
            const path = new THREE.CurvePath();
            path.add(curve);
            
            // To make it 3D, we use TubeGeometry on this path
            // Note: EllipseCurve is 2D. We need a 3D curve.
            const points = curve.getPoints(100);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // Simpler approach: LineLoop for thin lines, or Torus for thick rings
            // Let's use thick lines for visibility -> TubeGeometry requires 3D curve
            const curve3D = new THREE.CatmullRomCurve3(points.map(p => new THREE.Vector3(p.x, 0, p.y))); // Map 2D y to 3D z
            const tubeGeo = new THREE.TubeGeometry(curve3D, 64, thickness, 8, true);
            
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(tubeGeo, mat);
            return mesh;
        }

        // --- Build Scene Graph ---

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // Objects for Raycasting
        const interactables = [];

        // --- A. Left Side: 2s Sub-shell ---
        const group2s = new THREE.Group();
        group2s.position.set(-8, 0, 0);
        mainGroup.add(group2s);

        // 1. The Orbital (Sphere)
        const orbital2s = new THREE.Mesh(sphereGeo, new THREE.MeshStandardMaterial({ color: COLORS.orbital, roughness: 0.3 }));
        orbital2s.userData = { name: "2s Orbital", type: "orbital" };
        group2s.add(orbital2s);
        interactables.push(orbital2s);

        // 2. The Sub-shell Ring (Red)
        const subshellRing2s = createRing(2.5, 2.5, COLORS.subshell, 0.1);
        subshellRing2s.userData = { name: "2s Sub-shell", type: "subshell" };
        group2s.add(subshellRing2s);
        interactables.push(subshellRing2s);


        // --- B. Right Side: 2p Sub-shell ---
        const group2p = new THREE.Group();
        group2p.position.set(4, 0, 0); // Offset to right
        mainGroup.add(group2p);

        // 1. The Orbitals (3 Dumbbells)
        // Px
        const px = createDumbbell();
        px.rotation.z = Math.PI / 2; // Lie on X
        px.position.set(-4, 0, 0);
        px.userData = { name: "2px Orbital", type: "orbital" };
        // Add userData to children meshes for raycast
        px.children.forEach(c => { c.userData = px.userData; interactables.push(c); });
        group2p.add(px);

        // Py
        const py = createDumbbell();
        // Default is Y
        py.position.set(0, 0, 0);
        py.userData = { name: "2py Orbital", type: "orbital" };
        py.children.forEach(c => { c.userData = py.userData; interactables.push(c); });
        group2p.add(py);

        // Pz
        const pz = createDumbbell();
        pz.rotation.x = Math.PI / 2; // Lie on Z
        pz.position.set(4, 0, 0);
        pz.userData = { name: "2pz Orbital", type: "orbital" };
        pz.children.forEach(c => { c.userData = pz.userData; interactables.push(c); });
        group2p.add(pz);

        // 2. The Sub-shell Ring (Red)
        // Needs to encompass all 3 orbitals
        const subshellRing2p = createRing(7, 3.5, COLORS.subshell, 0.1);
        subshellRing2p.userData = { name: "2p Sub-shell", type: "subshell" };
        group2p.add(subshellRing2p);
        interactables.push(subshellRing2p);


        // --- C. The Shell (Blue) ---
        // Encompasses everything
        // Center of mass roughly at x=-2
        const shellRing = createRing(14, 6, COLORS.shell, 0.15);
        shellRing.position.set(-1, 0, 0);
        shellRing.userData = { name: "Shell (n=2)", type: "shell" };
        mainGroup.add(shellRing);
        interactables.push(shellRing);


        // --- Labels ---
        const labelData = [
            { text: "2s Orbital", pos: new THREE.Vector3(-8, 1.5, 0) },
            { text: "2s Sub-shell", pos: new THREE.Vector3(-8, 2.8, 0), color: "#e17055" },
            
            { text: "2px", pos: new THREE.Vector3(0, 1.5, 0) }, // Relative to group
            { text: "2py", pos: new THREE.Vector3(4, 1.5, 0) },
            { text: "2pz", pos: new THREE.Vector3(8, 1.5, 0) },
            
            { text: "2p Sub-shell", pos: new THREE.Vector3(4, 4, 0), color: "#e17055" },
            { text: "Principal Shell", pos: new THREE.Vector3(-1, 6.5, 0), color: "#0984e3" }
        ];

        // We'll create simple HTML labels
        const htmlLabels = [];
        
        function createLabel(text, worldPos, color) {
            const el = document.createElement('div');
            el.className = 'label';
            el.innerText = text;
            if(color) el.style.color = color;
            labelsContainer.appendChild(el);
            return { element: el, pos: worldPos };
        }

        // Add explicit positions
        htmlLabels.push(createLabel("2s", new THREE.Vector3(-8, 0, 0), null));
        htmlLabels.push(createLabel("2s Sub-shell", new THREE.Vector3(-8, 2.6, 0), "#c0392b"));
        
        htmlLabels.push(createLabel("2p_x", new THREE.Vector3(0, -1.5, 0), null));
        htmlLabels.push(createLabel("2p_y", new THREE.Vector3(4, -1.5, 0), null));
        htmlLabels.push(createLabel("2p_z", new THREE.Vector3(8, -1.5, 0), null));
        
        htmlLabels.push(createLabel("2p Sub-shell", new THREE.Vector3(4, 3.6, 0), "#c0392b"));
        htmlLabels.push(createLabel("Shell (n=2)", new THREE.Vector3(-2, 6.2, 0), "#0984e3"));


        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObj = null;

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        function handleHover() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactables);

            // Reset colors
            interactables.forEach(obj => {
                if(obj.material.emissive) obj.material.emissive.setHex(0x000000);
                if(obj.material.color && obj.userData.type === 'subshell') obj.material.color.setHex(COLORS.subshell);
                if(obj.material.color && obj.userData.type === 'shell') obj.material.color.setHex(COLORS.shell);
            });

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                
                // Highlight logic
                if (obj.userData.type === 'orbital') {
                    // Highlight specific orbital
                    if(obj.material.emissive) obj.material.emissive.setHex(0x333333);
                }
                
                if (obj.userData.type === 'subshell' || (obj.userData.type === 'orbital' && obj.parent.userData.name?.includes('2p'))) {
                    // If hovering orbital or its ring, highlight ring
                    // (Logic simplified for this demo)
                }
                
                // Simple color pop for rings
                if(obj.userData.type === 'subshell') obj.material.color.setHex(COLORS.highlight);
                if(obj.userData.type === 'shell') obj.material.color.setHex(COLORS.highlight);
                
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
        }


        // --- Animation ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            handleHover();

            // Rotate Orbitals slightly for life
            orbital2s.rotation.y += 0.01;
            px.children.forEach(c => c.rotation.y += 0.01);
            // Don't rotate whole group, just the "feeling" of activity
            
            // Labels Position Update
            htmlLabels.forEach(lbl => {
                const tempV = lbl.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.display = 'none';
                } else {
                    lbl.element.style.display = 'block';
                    lbl.element.style.left = x + 'px';
                    lbl.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
  </template>

  <template id="model-orbitals-hierarchy" data-source="2. Orbitals.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atomic Hierarchy: Shells > Subshells > Orbitals</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #f0f2f5 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #34495e; 
            transition: all 0.3s ease;
        }

        h1 {
            margin: 0 0 5px 0;
            font-size: 1.4rem;
            color: #2c3e50;
        }

        h2 {
            margin: 0 0 10px 0;
            font-size: 1rem;
            color: #7f8c8d;
            font-weight: normal;
        }
        
        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #555;
            margin-bottom: 15px;
        }

        .breadcrumb {
            display: flex;
            gap: 5px;
            font-size: 0.85rem;
            margin-bottom: 15px;
            background: #ecf0f1;
            padding: 8px;
            border-radius: 6px;
        }
        .crumb {
            color: #3498db;
            cursor: pointer;
            text-decoration: underline;
        }
        .crumb.active {
            color: #2c3e50;
            text-decoration: none;
            cursor: default;
            font-weight: bold;
        }

        .instruction {
            margin-top: 15px;
            font-size: 0.8rem;
            font-style: italic;
            color: #888;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        /* 3D Labels */
        .obj-label {
            position: absolute;
            background: white;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #2c3e50;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: 1px solid #ddd;
            transition: opacity 0.3s;
        }

        /* Back Button */
        #btn-back {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 25px;
            background: #34495e;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: none; /* Hidden initially */
            pointer-events: auto;
            z-index: 100;
        }
        #btn-back:hover { background: #2c3e50; }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/examples/jsm/libs/tween.module.min": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.min.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card" id="info-card">
            <h1>Atomic Structure</h1>
            <h2 id="view-subtitle">Level: Principal Shells</h2>
            
            <div class="breadcrumb" id="breadcrumbs">
                <span class="crumb active" id="crumb-shells">Shells</span>
            </div>

            <p id="desc-text">
                Electrons are arranged in Principal Shells (n=1, n=2, n=3).
            </p>
            
            <div class="instruction" id="instruction-text">
                Click on a ring (e.g., n=3) to see its contents.
            </div>
        </div>
    </div>

    <button id="btn-back" onclick="goBack()">‚¨Ü Zoom Out</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import TWEEN from 'three/examples/jsm/libs/tween.module.min';

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();
        // White background with subtle fog
        scene.fog = new THREE.Fog(0xffffff, 20, 60);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 20, 20); // Top-down-ish view

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 50;

        // --- Lights ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- State Management ---
        const VIEW_LEVELS = {
            SHELLS: 0,
            SUBSHELLS: 1,
            ORBITALS: 2
        };
        let currentLevel = VIEW_LEVELS.SHELLS;
        let selectedShell = null;
        let selectedSubshell = null;

        // Groups
        const shellGroup = new THREE.Group();
        const subshellGroup = new THREE.Group();
        const orbitalGroup = new THREE.Group();
        
        scene.add(shellGroup);
        scene.add(subshellGroup);
        scene.add(orbitalGroup);

        subshellGroup.visible = false;
        orbitalGroup.visible = false;

        // Interactive Objects
        const interactables = [];
        const labels = [];

        // --- Geometry Helpers ---
        
        function createRing(radius, thickness, color, name) {
            const geometry = new THREE.RingGeometry(radius, radius + thickness, 64);
            const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2; // Flat on ground
            mesh.userData = { name: name, type: 'ring', radius: radius };
            return mesh;
        }
        
        function createSphere(radius, color, name) {
            const geo = new THREE.SphereGeometry(radius, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4, metalness: 0.1 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData = { name: name, type: 'sphere' };
            return mesh;
        }

        function createLabel(text, position) {
            const el = document.createElement('div');
            el.className = 'obj-label';
            el.innerText = text;
            labelsContainer.appendChild(el);
            labels.push({ element: el, pos: position, group: 'shell' }); // Default group
            return el;
        }

        // --- Build Level 1: Shells ---
        // Nucleus
        const nucleus = createSphere(0.8, 0x333333, "Nucleus");
        shellGroup.add(nucleus);

        // Shells n=1, n=2, n=3
        const shellsData = [
            { n: 1, r: 3, color: 0x3498db },
            { n: 2, r: 6, color: 0x3498db },
            { n: 3, r: 9, color: 0x3498db }
        ];

        shellsData.forEach(s => {
            const ring = createRing(s.r, 0.4, s.color, `Shell n=${s.n}`);
            ring.userData.level = VIEW_LEVELS.SHELLS;
            ring.userData.id = s.n;
            shellGroup.add(ring);
            interactables.push(ring);

            // Label
            const lbl = createLabel(`n=${s.n}`, new THREE.Vector3(s.r + 0.2, 0, 0));
            labels[labels.length-1].group = 'shell';
        });

        // --- Navigation Logic ---

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', onMouseClick);
        window.addEventListener('mousemove', onMouseMove);

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const visibleInteractables = interactables.filter(obj => obj.parent.visible);
            const intersects = raycaster.intersectObjects(visibleInteractables);

            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
                // Optional: Highlight
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const visibleInteractables = interactables.filter(obj => obj.parent.visible);
            const intersects = raycaster.intersectObjects(visibleInteractables);

            if (intersects.length > 0) {
                const target = intersects[0].object;
                
                if (currentLevel === VIEW_LEVELS.SHELLS) {
                    enterSubshells(target.userData.id);
                } else if (currentLevel === VIEW_LEVELS.SUBSHELLS) {
                    enterOrbitals(target.userData.subshellType);
                }
            }
        }

        // --- Transitions ---

        function enterSubshells(n) {
            selectedShell = n;
            currentLevel = VIEW_LEVELS.SUBSHELLS;
            
            // 1. Hide Shells
            new TWEEN.Tween(shellGroup.scale).to({x: 3, y: 3, z: 3}, 500).easing(TWEEN.Easing.Back.In).start();
            new TWEEN.Tween(shellGroup.position).to({y: -50}, 500).onComplete(() => {
                shellGroup.visible = false;
                buildSubshells(n);
                subshellGroup.visible = true;
                subshellGroup.scale.set(0,0,0);
                subshellGroup.position.set(0,0,0);
                new TWEEN.Tween(subshellGroup.scale).to({x: 1, y: 1, z: 1}, 600).easing(TWEEN.Easing.Back.Out).start();
            }).start();

            // UI Update
            updateUI();
        }

        function buildSubshells(n) {
            // Clear previous
            while(subshellGroup.children.length > 0){ 
                const child = subshellGroup.children[0];
                subshellGroup.remove(child);
                // Remove from interactables
                const idx = interactables.indexOf(child);
                if (idx > -1) interactables.splice(idx, 1);
            }
            // Clear Subshell labels
            labels.forEach(l => { if(l.group === 'subshell') l.element.style.display = 'none'; });
            const tempLabels = labels.filter(l => l.group !== 'subshell');
            labels.length = 0; 
            labels.push(...tempLabels);

            // Logic: n=1 -> s; n=2 -> s, p; n=3 -> s, p, d
            const types = ['s', 'p', 'd', 'f'];
            const count = Math.min(n, 3); // Limit to d for simplicity in visualization

            // Create Visual "Bubbles" for subshells
            for(let i=0; i<count; i++) {
                const type = types[i];
                const sphere = createSphere(2.5, 0x27ae60, `${type}-subshell`); // Greenish
                
                // Position them in a line or triangle
                const offset = (i - (count-1)/2) * 7;
                sphere.position.set(offset, 0, 0);
                
                sphere.userData.level = VIEW_LEVELS.SUBSHELLS;
                sphere.userData.subshellType = type;
                
                subshellGroup.add(sphere);
                interactables.push(sphere);

                // Add text label
                const l = createLabel(`${n}${type}`, new THREE.Vector3(offset, 3.5, 0));
                labels[labels.length-1].group = 'subshell';
            }
        }

        function enterOrbitals(type) {
            selectedSubshell = type;
            currentLevel = VIEW_LEVELS.ORBITALS;

            // Hide Subshells
            new TWEEN.Tween(subshellGroup.scale).to({x: 3, y: 3, z: 3}, 500).easing(TWEEN.Easing.Back.In).start();
            new TWEEN.Tween(subshellGroup.position).to({y: -50}, 500).onComplete(() => {
                subshellGroup.visible = false;
                buildOrbitals(type);
                orbitalGroup.visible = true;
                orbitalGroup.scale.set(0,0,0);
                orbitalGroup.position.set(0,0,0);
                new TWEEN.Tween(orbitalGroup.scale).to({x: 1, y: 1, z: 1}, 600).easing(TWEEN.Easing.Back.Out).start();
            }).start();

            updateUI();
        }

        function buildOrbitals(type) {
            // Clear previous
             while(orbitalGroup.children.length > 0){ 
                const child = orbitalGroup.children[0];
                orbitalGroup.remove(child);
            }
            // Clear Orbital labels
             const tempLabels = labels.filter(l => l.group !== 'orbital');
            labels.length = 0; 
            labels.push(...tempLabels);

            // Visuals
            const mat = new THREE.MeshStandardMaterial({ color: 0xe74c3c, roughness: 0.3, metalness: 0.1 }); // Reddish
            
            if (type === 's') {
                // One sphere
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32), mat);
                orbitalGroup.add(mesh);
                const l = createLabel(`s orbital`, new THREE.Vector3(0, 3, 0));
                labels[labels.length-1].group = 'orbital';
            } else if (type === 'p') {
                // 3 Dumbbells (simplified as pairs of spheres)
                const offsets = [
                    { x: -6, l: 'px' }, { x: 0, l: 'py' }, { x: 6, l: 'pz' }
                ];
                offsets.forEach(o => {
                    const group = new THREE.Group();
                    const s1 = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), mat); s1.position.y = 1;
                    const s2 = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), mat); s2.position.y = -1;
                    group.add(s1, s2);
                    group.position.x = o.x;
                    
                    // Rotate based on axis (visual fake for simplicity in 2D layout)
                    if(o.l === 'px') group.rotation.z = Math.PI/2;
                    if(o.l === 'pz') group.rotation.x = Math.PI/2;
                    
                    orbitalGroup.add(group);
                    
                    const l = createLabel(o.l, new THREE.Vector3(o.x, 2.5, 0));
                    labels[labels.length-1].group = 'orbital';
                });
            } else if (type === 'd') {
                // 5 blobs
                for(let i=0; i<5; i++) {
                     const mesh = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16, 16), mat);
                     mesh.position.x = (i - 2) * 4;
                     orbitalGroup.add(mesh);
                     const l = createLabel(`d${i+1}`, new THREE.Vector3((i - 2) * 4, 2, 0));
                     labels[labels.length-1].group = 'orbital';
                }
            }
        }

        window.goBack = function() {
            if (currentLevel === VIEW_LEVELS.ORBITALS) {
                // Go to Subshells
                currentLevel = VIEW_LEVELS.SUBSHELLS;
                orbitalGroup.visible = false;
                
                subshellGroup.visible = true;
                subshellGroup.scale.set(0,0,0);
                subshellGroup.position.set(0,0,0);
                new TWEEN.Tween(subshellGroup.scale).to({x: 1, y: 1, z: 1}, 600).easing(TWEEN.Easing.Back.Out).start();
                
            } else if (currentLevel === VIEW_LEVELS.SUBSHELLS) {
                // Go to Shells
                currentLevel = VIEW_LEVELS.SHELLS;
                subshellGroup.visible = false;
                
                shellGroup.visible = true;
                shellGroup.scale.set(0,0,0);
                shellGroup.position.set(0,0,0);
                new TWEEN.Tween(shellGroup.scale).to({x: 1, y: 1, z: 1}, 600).easing(TWEEN.Easing.Back.Out).start();
                selectedShell = null;
            }
            updateUI();
        };

        function updateUI() {
            const subtitle = document.getElementById('view-subtitle');
            const desc = document.getElementById('desc-text');
            const instr = document.getElementById('instruction-text');
            const btn = document.getElementById('btn-back');
            const breadcrumbs = document.getElementById('breadcrumbs');

            let crumbHTML = '';

            if (currentLevel === VIEW_LEVELS.SHELLS) {
                subtitle.innerText = "Level: Principal Shells";
                desc.innerText = "Electrons are arranged in Principal Shells (n=1, n=2, n=3).";
                instr.innerText = "Click on a ring (e.g., n=3) to zoom in.";
                btn.style.display = 'none';
                crumbHTML = `<span class="crumb active">Shells</span>`;
            } 
            else if (currentLevel === VIEW_LEVELS.SUBSHELLS) {
                subtitle.innerText = `Level: Subshells (n=${selectedShell})`;
                desc.innerText = `Shell ${selectedShell} is divided into subshells (s, p, d...).`;
                instr.innerText = "Click on a subshell to see its orbitals.";
                btn.style.display = 'block';
                crumbHTML = `<span class="crumb" onclick="goBack()">Shells</span> > <span class="crumb active">Subshells</span>`;
            } 
            else if (currentLevel === VIEW_LEVELS.ORBITALS) {
                subtitle.innerText = `Level: Orbitals (${selectedShell}${selectedSubshell})`;
                desc.innerText = `Subshells are divided into Orbitals which hold the electrons.`;
                instr.innerText = "View Mode Only.";
                btn.style.display = 'block';
                crumbHTML = `<span class="crumb" onclick="goBack(); setTimeout(goBack, 100);">Shells</span> > <span class="crumb" onclick="goBack()">Subshells</span> > <span class="crumb active">Orbitals</span>`;
            }
            breadcrumbs.innerHTML = crumbHTML;
        }

        // --- Render Loop ---
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            // Label Positioning
            labels.forEach(lbl => {
                // Only show if group matches active view or persistent
                let isVisible = false;
                if(currentLevel === VIEW_LEVELS.SHELLS && lbl.group === 'shell') isVisible = true;
                if(currentLevel === VIEW_LEVELS.SUBSHELLS && lbl.group === 'subshell') isVisible = true;
                if(currentLevel === VIEW_LEVELS.ORBITALS && lbl.group === 'orbital') isVisible = true;

                if (!isVisible) {
                    lbl.element.style.display = 'none';
                    return;
                }

                lbl.element.style.display = 'block';
                const tempV = lbl.pos.clone();
                
                // If in a group that is scaled/moved, we need to account for that world matrix
                // Simplified: We reset positions every build, so local=world mostly
                
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.opacity = 0;
                } else {
                    lbl.element.style.opacity = 1;
                    lbl.element.style.left = x + 'px';
                    lbl.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
  </template>

  <template id="model-orbitals-shapes" data-source="2. Orbitals Orbital Shapes.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electron Orbital Shapes</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #f0f2f5 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #2ecc71; /* Green to match image */
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            color: #27ae60;
        }
        
        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #555;
            margin-bottom: 15px;
        }

        /* Controls */
        .control-group {
            margin-bottom: 15px;
        }
        
        .label {
            font-size: 0.8rem;
            font-weight: bold;
            color: #999;
            margin-bottom: 5px;
            display: block;
            text-transform: uppercase;
        }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .btn {
            background: #eef2f5;
            border: 1px solid #dcdde1;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            color: #555;
            transition: all 0.2s;
            text-align: center;
        }
        .btn:hover {
            background: #dfe4ea;
        }
        .btn.active {
            background: #2ecc71;
            color: white;
            border-color: #27ae60;
        }

        .toggle-row {
            display: flex;
            background: #eef2f5;
            border-radius: 6px;
            padding: 2px;
            margin-top: 5px;
        }
        .toggle-btn {
            flex: 1;
            border: none;
            background: transparent;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #777;
        }
        .toggle-btn.active {
            background: white;
            color: #2ecc71;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            font-weight: bold;
        }

        /* Axis Labels */
        .axis-label {
            position: absolute;
            font-weight: bold;
            font-family: monospace;
            font-size: 1.2rem;
            pointer-events: none;
            user-select: none;
        }
        .x-axis { color: #e74c3c; }
        .y-axis { color: #2ecc71; }
        .z-axis { color: #3498db; }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>Orbital Shapes</h1>
            <p id="desc-text">Select an orbital to visualize its shape and orientation in 3D space.</p>
            
            <div class="control-group">
                <span class="label">Select Type</span>
                <div class="btn-grid">
                    <button class="btn active" onclick="setOrbital('s')">s orbital</button>
                    <button class="btn" onclick="setOrbital('px')">p_x orbital</button>
                    <button class="btn" onclick="setOrbital('py')">p_y orbital</button>
                    <button class="btn" onclick="setOrbital('pz')">p_z orbital</button>
                </div>
                <button class="btn" style="width: 100%; margin-top: 8px;" onclick="setOrbital('all')">Show All p-orbitals</button>
            </div>

            <div class="control-group">
                <span class="label">Visualization Style</span>
                <div class="toggle-row">
                    <button class="toggle-btn active" id="btn-solid" onclick="setStyle('solid')">Solid (Cloud)</button>
                    <button class="toggle-btn" id="btn-wire" onclick="setStyle('wire')">Schematic</button>
                </div>
            </div>
            
            <div style="font-size: 0.8rem; color: #888; margin-top: 10px;">
                ‚óè Black dot = Nucleus<br>
                Drag to rotate ‚Ä¢ Scroll to zoom
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(8, 6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Lights ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(-5, -5, -5);
        scene.add(backLight);

        // --- Axes Helper & Labels ---
        // Custom axes to look cleaner
        function createAxisLine(points, color) {
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: color });
            return new THREE.Line(geo, mat);
        }

        const axisLength = 5;
        const groupAxes = new THREE.Group();
        
        // X Axis (Red-ish)
        groupAxes.add(createAxisLine([new THREE.Vector3(-axisLength,0,0), new THREE.Vector3(axisLength,0,0)], 0x333333));
        // Y Axis (Green-ish)
        groupAxes.add(createAxisLine([new THREE.Vector3(0,-axisLength,0), new THREE.Vector3(0,axisLength,0)], 0x333333));
        // Z Axis (Blue-ish)
        groupAxes.add(createAxisLine([new THREE.Vector3(0,0,-axisLength), new THREE.Vector3(0,0,axisLength)], 0x333333));
        
        scene.add(groupAxes);

        // HTML Labels for axes
        const axisLabels = [
            { text: 'X', pos: new THREE.Vector3(axisLength + 0.5, 0, 0), class: 'x-axis' },
            { text: 'Y', pos: new THREE.Vector3(0, axisLength + 0.5, 0), class: 'y-axis' },
            { text: 'Z', pos: new THREE.Vector3(0, 0, axisLength + 0.5), class: 'z-axis' }
        ];

        axisLabels.forEach(lbl => {
            const el = document.createElement('div');
            el.className = `axis-label ${lbl.class}`;
            el.innerText = lbl.text;
            labelsContainer.appendChild(el);
            lbl.element = el;
        });


        // --- Orbitals ---
        const orbitalGroup = new THREE.Group();
        scene.add(orbitalGroup);

        // Nucleus
        const nucleus = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        scene.add(nucleus);

        // Materials
        const colorOrbital = 0x2ecc71; // Green from diagram
        
        const matSolid = new THREE.MeshPhysicalMaterial({ 
            color: colorOrbital, 
            transparent: true, 
            opacity: 0.6,
            roughness: 0.2,
            metalness: 0.1,
            clearcoat: 1.0,
            side: THREE.DoubleSide
        });

        const matWire = new THREE.MeshBasicMaterial({ 
            color: 0x27ae60, 
            wireframe: true 
        });

        let currentMat = matSolid;

        // Geometry Generators
        function createSOrbital() {
            const geo = new THREE.SphereGeometry(2, 32, 32);
            return new THREE.Mesh(geo, currentMat);
        }

        function createLobe(position, rotation) {
            // A lobe is essentially a sphere moved and stretched, or a pear shape.
            // Simplified: Stretched sphere
            const geo = new THREE.SphereGeometry(1, 32, 32);
            geo.scale(1, 2, 1); // Elongate along Y
            geo.translate(0, 1, 0); // Move origin to base
            
            const mesh = new THREE.Mesh(geo, currentMat);
            mesh.position.copy(position);
            mesh.rotation.copy(rotation);
            return mesh;
        }

        function createPOrbital(axis) {
            const group = new THREE.Group();
            
            if (axis === 'x') {
                // Lobe 1 (+X)
                const l1 = createLobe(new THREE.Vector3(0,0,0), new THREE.Euler(0, 0, -Math.PI/2));
                // Lobe 2 (-X)
                const l2 = createLobe(new THREE.Vector3(0,0,0), new THREE.Euler(0, 0, Math.PI/2));
                group.add(l1, l2);
            } 
            else if (axis === 'y') {
                // Lobe 1 (+Y)
                const l1 = createLobe(new THREE.Vector3(0,0,0), new THREE.Euler(0, 0, 0));
                // Lobe 2 (-Y)
                const l2 = createLobe(new THREE.Vector3(0,0,0), new THREE.Euler(0, 0, Math.PI));
                group.add(l1, l2);
            }
            else if (axis === 'z') {
                // Lobe 1 (+Z)
                const l1 = createLobe(new THREE.Vector3(0,0,0), new THREE.Euler(Math.PI/2, 0, 0));
                // Lobe 2 (-Z)
                const l2 = createLobe(new THREE.Vector3(0,0,0), new THREE.Euler(-Math.PI/2, 0, 0));
                group.add(l1, l2);
            }
            
            return group;
        }

        // --- State & Update ---
        let currentType = 's';
        let currentStyle = 'solid';

        function updateScene() {
            // Clear current
            while(orbitalGroup.children.length > 0){ 
                orbitalGroup.remove(orbitalGroup.children[0]); 
            }

            // Update Material
            currentMat = (currentStyle === 'solid') ? matSolid : matWire;
            
            // Description Update
            const desc = document.getElementById('desc-text');

            if (currentType === 's') {
                orbitalGroup.add(createSOrbital());
                desc.innerText = "s orbitals are spherical in shape. The probability of finding an electron is the same in all directions.";
            } 
            else if (currentType === 'px') {
                orbitalGroup.add(createPOrbital('x'));
                desc.innerText = "p_x orbital: Dumbbell-shaped lobes aligned along the X-axis.";
            }
            else if (currentType === 'py') {
                orbitalGroup.add(createPOrbital('y'));
                desc.innerText = "p_y orbital: Dumbbell-shaped lobes aligned along the Y-axis.";
            }
            else if (currentType === 'pz') {
                orbitalGroup.add(createPOrbital('z'));
                desc.innerText = "p_z orbital: Dumbbell-shaped lobes aligned along the Z-axis. Note the perspective.";
            }
            else if (currentType === 'all') {
                // Add all 3 P orbitals
                const px = createPOrbital('x');
                const py = createPOrbital('y');
                const pz = createPOrbital('z');
                
                // Slightly color tint them differently to distinguish? 
                // Or keep uniform? Let's keep uniform to match diagram style, 
                // but maybe scale slightly to prevent Z-fighting if they overlap perfectly at center
                px.scale.setScalar(1.0);
                py.scale.setScalar(1.0);
                pz.scale.setScalar(1.0);

                orbitalGroup.add(px, py, pz);
                desc.innerText = "All three p-orbitals arranged together. They are mutually perpendicular.";
            }
        }

        // --- Global Functions for UI ---
        window.setOrbital = function(type) {
            currentType = type;
            
            // UI Update
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            // Simple match logic for button highlighting
            const btns = document.querySelectorAll('.btn');
            if(type === 's') btns[0].classList.add('active');
            if(type === 'px') btns[1].classList.add('active');
            if(type === 'py') btns[2].classList.add('active');
            if(type === 'pz') btns[3].classList.add('active');
            if(type === 'all') btns[4].classList.add('active');

            updateScene();
        }

        window.setStyle = function(style) {
            currentStyle = style;
            
            document.getElementById('btn-solid').classList.toggle('active', style === 'solid');
            document.getElementById('btn-wire').classList.toggle('active', style === 'wire');
            
            updateScene();
        }

        // Initial Load
        updateScene();


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Axis Label Positions
            axisLabels.forEach(lbl => {
                const tempV = lbl.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                // Simple check if behind camera
                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.display = 'none';
                } else {
                    lbl.element.style.display = 'block';
                    lbl.element.style.left = x + 'px';
                    lbl.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
  </template>

  <template id="model-orbitals-s-expansion" data-source="2. Orbitals s_orbital_expansion.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>s-Orbital Expansion & Nodes</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #f0f2f5 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #e17055; /* Reddish Orange */
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            color: #c0392b;
        }
        
        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #555;
            margin-bottom: 15px;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .slider-container {
            margin-bottom: 5px;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
        }
        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .toggle-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        .toggle-btn {
            background: #eef2f5;
            border: 1px solid #dcdde1;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            color: #777;
            transition: all 0.2s;
        }
        .toggle-btn.active {
            background: #e17055;
            color: white;
            border-color: #d35400;
        }

        /* 3D Labels */
        .obj-label {
            position: absolute;
            background: rgba(255,255,255,0.9);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            color: #c0392b;
            pointer-events: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transform: translate(-50%, -50%);
        }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/examples/jsm/libs/tween.module.min": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.min.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>s-Orbital Expansion</h1>
            <p>
                As the principal quantum number (n) increases, the orbital size increases and nodes (gaps) appear.
            </p>
            
            <div class="controls">
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Cut View (Slice)</span>
                        <span id="slice-val">90¬∞</span>
                    </div>
                    <input type="range" id="slice-slider" min="0" max="360" value="90" step="1">
                </div>

                <div class="toggle-grid">
                    <button class="toggle-btn active" id="btn-1s" onclick="toggleLayer(1)">1s</button>
                    <button class="toggle-btn active" id="btn-2s" onclick="toggleLayer(2)">2s</button>
                    <button class="toggle-btn active" id="btn-3s" onclick="toggleLayer(3)">3s</button>
                </div>
            </div>
            
            <div style="margin-top: 15px; font-size: 0.8rem; color: #888; border-top: 1px solid #eee; padding-top: 8px;">
                Drag the "Cut View" slider to see inside the atom!
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();
        // scene.background = new THREE.Color(0xffffff);
        scene.fog = new THREE.Fog(0xffffff, 20, 60);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(12, 12, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.localClippingEnabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Lights ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0xffedd0, 0.4);
        fillLight.position.set(-10, 0, -10);
        scene.add(fillLight);

        // --- Axes (Matching Diagram) ---
        const axesHelper = new THREE.AxesHelper(8);
        // Custom colors for axes
        const colors = axesHelper.geometry.attributes.color;
        // X (Red), Y (Green), Z (Blue) - default is fine, but let's make them black/grey to match sketch
        // Actually, we'll draw custom arrow lines for cleaner look
        const axisGroup = new THREE.Group();
        scene.add(axisGroup);
        
        function createAxis(dir, label) {
            const points = [new THREE.Vector3(0,0,0), dir.clone().multiplyScalar(10)];
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x333333 }));
            axisGroup.add(line);
            
            // Arrowhead
            const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0,0,0), 10, 0x333333, 0.5, 0.3);
            axisGroup.add(arrow);
        }
        createAxis(new THREE.Vector3(1,0,0), 'x');
        createAxis(new THREE.Vector3(0,1,0), 'z'); // Up is Z in diagram? Or Y? Diagram has vertical Z.
        createAxis(new THREE.Vector3(0,0,1), 'y');
        
        // --- Orbitals ---
        const orbitalGroup = new THREE.Group();
        scene.add(orbitalGroup);

        const matParams = {
            color: 0xe74c3c, // Red
            roughness: 0.4,
            metalness: 0.1,
            side: THREE.DoubleSide,
            flatShading: false
        };

        // Data for orbitals
        // 1s: Solid sphere
        // 2s: Shell with gap
        // 3s: Shell with gap
        // To visualize "Nodes", we physically separate the geometries
        
        const orbitals = [
            { id: 1, name: '1s', rInner: 0, rOuter: 1.5, mesh: null, visible: true },
            { id: 2, name: '2s', rInner: 2.5, rOuter: 4.0, mesh: null, visible: true },
            { id: 3, name: '3s', rInner: 5.0, rOuter: 7.0, mesh: null, visible: true }
        ];

        // Labels
        const htmlLabels = [];
        orbitals.forEach(o => {
            const el = document.createElement('div');
            el.className = 'obj-label';
            el.innerText = o.name;
            labelsContainer.appendChild(el);
            htmlLabels.push({ element: el, pos: new THREE.Vector3(0, o.rOuter + 0.5, 0), visible: true });
        });

        // Add Axis Labels
        function addAxisLabel(text, pos) {
            const el = document.createElement('div');
            el.className = 'obj-label';
            el.style.color = '#333';
            el.style.background = 'none';
            el.style.boxShadow = 'none';
            el.style.fontSize = '1.2rem';
            el.innerText = text;
            labelsContainer.appendChild(el);
            htmlLabels.push({ element: el, pos: pos, visible: true });
        }
        addAxisLabel('z', new THREE.Vector3(0, 10.5, 0));
        addAxisLabel('x', new THREE.Vector3(10.5, 0, 0));
        addAxisLabel('y', new THREE.Vector3(0, 0, 10.5));


        // --- Update Geometry Function ---
        // We recreate geometry when slider moves to create the "Cut" effect
        // SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)
        
        let currentSliceAngle = Math.PI / 2; // 90 degrees cut out (showing 270)
        // Wait, diagram shows a 90 degree wedge REMOVED? Or 90 degree wedge KEPT?
        // Diagram shows a cross section, roughly 1/4 removed to show inside.
        // So we want to draw 75% of the sphere.
        
        function updateGeometries() {
            // Calculate phiLength based on slider
            // Slider 0 -> Full Sphere (2PI)
            // Slider 360 -> Nothing (0)
            // Let's interpret slider as "Angle of Cutout"
            // If slider = 90, we draw 360-90 = 270 degrees.
            
            const cutDeg = parseFloat(document.getElementById('slice-slider').value);
            const drawRad = (360 - cutDeg) * (Math.PI / 180);

            orbitals.forEach(o => {
                if (o.mesh) {
                    orbitalGroup.remove(o.mesh);
                    o.mesh.geometry.dispose();
                }
                
                if (!o.visible) return;

                // To make a thick shell with a cut, we need nested geometries or a shape.
                // Simple approximation: Just the outer surface? No, we need to see thickness.
                // We can use a RingGeometry extruded? No.
                // Best simple way: SphereGeometry with side: DoubleSide.
                // 1s is solid.
                // 2s and 3s are shells. To see "thickness" when cut, we ideally need to close the mesh.
                // Creating a closed "thick shell" wedge procedurally is complex.
                // Visual Hack: Just render the sphere sheet. DoubleSide handles visibility.
                
                // Note: SphereGeometry phiLength measures around Y axis.
                
                const geo = new THREE.SphereGeometry(o.rOuter, 64, 32, 0, drawRad);
                
                // For 2s and 3s, they are "shells".
                // We can simulate the visual of a shell by just rendering the outer sphere.
                // Since we have DoubleSide, we see the inside red wall.
                // The gap between 1s and 2s serves as the "node".
                
                const mat = new THREE.MeshStandardMaterial(matParams);
                
                // Darken inner ones slightly for contrast
                if(o.id === 1) mat.color.setHex(0xc0392b); // Darkest
                if(o.id === 2) mat.color.setHex(0xe74c3c);
                if(o.id === 3) mat.color.setHex(0xff7675); // Lightest

                o.mesh = new THREE.Mesh(geo, mat);
                
                // Rotate to align cut with camera/diagram nicely
                o.mesh.rotation.y = Math.PI / 4; 
                
                orbitalGroup.add(o.mesh);
            });
        }

        // --- Event Listeners ---
        const slider = document.getElementById('slice-slider');
        const sliceVal = document.getElementById('slice-val');
        
        slider.addEventListener('input', (e) => {
            sliceVal.innerText = e.target.value + '¬∞';
            updateGeometries();
        });

        window.toggleLayer = function(id) {
            const orb = orbitals.find(o => o.id === id);
            orb.visible = !orb.visible;
            
            // Toggle Button Style
            const btn = document.getElementById(`btn-${id}s`);
            btn.classList.toggle('active');
            
            // Toggle Label Visibility
            // Find the label for this orbital
            // Since we reconstructed htmlLabels array manually, 0,1,2 correspond to 1s,2s,3s
            htmlLabels[id-1].visible = orb.visible;
            
            updateGeometries();
        };

        // Initial Build
        updateGeometries();


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Label Positioning
            htmlLabels.forEach(lbl => {
                if (!lbl.visible) {
                    lbl.element.style.display = 'none';
                    return;
                }
                lbl.element.style.display = 'block';

                const tempV = lbl.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.opacity = 0;
                } else {
                    lbl.element.style.opacity = 1;
                    lbl.element.style.left = x + 'px';
                    lbl.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateGeometries();
        });

    </script>
</body>
</html>
  </template>

  <template id="model-filling-order" data-source="3. Configuration & Filling -  filling order.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aufbau Principle: Sub-shell Filling</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #f0f2f5 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #d63031; /* Red to match arrows */
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            color: #2d3436;
        }
        
        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #636e72;
            margin-bottom: 15px;
        }

        .status-box {
            background: #f1f2f6;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        #current-step {
            font-size: 1.2rem;
            font-weight: bold;
            color: #d63031;
            display: block;
            margin-bottom: 4px;
        }
        
        #electron-count {
            font-size: 0.8rem;
            color: #888;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.8rem;
        }
        
        .btn-primary {
            background: #d63031;
            color: white;
            box-shadow: 0 4px 10px rgba(214, 48, 49, 0.3);
        }
        .btn-primary:hover { background: #c0392b; transform: translateY(-1px); }
        .btn-primary:active { transform: translateY(1px); }
        .btn-primary:disabled { background: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }

        .btn-secondary {
            background: #dfe6e9;
            color: #2d3436;
        }
        .btn-secondary:hover { background: #b2bec3; }

        /* 3D Labels */
        .node-label {
            position: absolute;
            font-weight: bold;
            font-size: 1rem;
            color: #2d3436;
            pointer-events: none;
            transform: translate(-50%, -50%);
            text-shadow: 0 0 5px white;
        }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/examples/jsm/libs/tween.module.min": "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.min.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>Filling Sub-shells</h1>
            <p>The "Diagonal Rule" showing the order of energy levels.</p>
            
            <div class="status-box">
                <span id="current-step">Start</span>
                <span id="electron-count">0 Electrons Filled</span>
            </div>

            <div class="controls">
                <button class="btn btn-primary" id="btn-next" onclick="toggleAutoPlay()">Start Auto-Fill</button>
                <button class="btn btn-secondary" onclick="resetSim()">Reset</button>
            </div>
            
            <p style="margin-top: 15px; font-size: 0.8rem; font-style: italic; color: #888;">
                Note how 4s fills before 3d because it has lower energy!
            </p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import TWEEN from 'three/examples/jsm/libs/tween.module.min';

        // --- Data Structure ---
        // Layout: Grid [Row(n), Col(l)]
        // Using standard chart layout: 
        // 1s
        // 2s 2p
        // 3s 3p 3d
        // 4s 4p 4d 4f
        
        const NODES = [
            { name: '1s', n: 1, l: 0, x: 0, y: 0 },
            
            { name: '2s', n: 2, l: 0, x: 0, y: -2 },
            { name: '2p', n: 2, l: 1, x: 2, y: -2 },
            
            { name: '3s', n: 3, l: 0, x: 0, y: -4 },
            { name: '3p', n: 3, l: 1, x: 2, y: -4 },
            { name: '3d', n: 3, l: 2, x: 4, y: -4 },
            
            { name: '4s', n: 4, l: 0, x: 0, y: -6 },
            { name: '4p', n: 4, l: 1, x: 2, y: -6 },
            { name: '4d', n: 4, l: 2, x: 4, y: -6 },
            { name: '4f', n: 4, l: 3, x: 6, y: -6 }
        ];

        // The Aufbau Order (Indices in NODES array)
        const FILL_ORDER = [0, 1, 2, 3, 4, 6, 5, 7]; 

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xf0f2f5, 20, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(2, -3, 0); // Center view roughly

        // --- Lights ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(5, 10, 10);
        scene.add(dirLight);

        // --- Scene Elements ---
        
        const nodeMeshes = [];
        const labels = [];
        const arrowGroup = new THREE.Group();
        scene.add(arrowGroup);

        // Materials
        const matEmpty = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.1, transparent: true, opacity: 0.8 });
        const matFilled = new THREE.MeshStandardMaterial({ color: 0xd63031, roughness: 0.2, metalness: 0.2, emissive: 0xa30000, emissiveIntensity: 0.4 });
        
        // Build Nodes
        const geo = new THREE.SphereGeometry(0.7, 32, 32);

        NODES.forEach((node, idx) => {
            const mesh = new THREE.Mesh(geo, matEmpty.clone());
            mesh.position.set(node.x, node.y, 0);
            scene.add(mesh);
            nodeMeshes[idx] = mesh;

            // HTML Label
            const el = document.createElement('div');
            el.className = 'node-label';
            el.innerText = node.name;
            labelsContainer.appendChild(el);
            labels.push({ element: el, pos: mesh.position });
        });

        // --- Animation Logic ---
        let currentStepIndex = -1;
        let isAutoPlaying = false;
        let autoPlayTimeout = null;
        let isAnimating = false;

        // Marker for the active "filling" process
        const fillerGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const fillerMat = new THREE.MeshBasicMaterial({ color: 0xffea00 }); // Yellow
        const fillerParticle = new THREE.Mesh(fillerGeo, fillerMat);
        fillerParticle.visible = false;
        scene.add(fillerParticle);

        window.toggleAutoPlay = function() {
            if(currentStepIndex >= FILL_ORDER.length - 1) return; // Done

            isAutoPlaying = !isAutoPlaying;
            const btn = document.getElementById('btn-next');
            
            if(isAutoPlaying) {
                btn.innerText = "Pause";
                btn.classList.add('btn-secondary'); // Visual feedback
                if(!isAnimating) {
                    processNextStep();
                }
            } else {
                btn.innerText = "Resume Auto-Fill";
                btn.classList.remove('btn-secondary');
                if(autoPlayTimeout) clearTimeout(autoPlayTimeout);
            }
        };

        function processNextStep() {
            if (currentStepIndex >= FILL_ORDER.length - 1) {
                isAutoPlaying = false;
                const btn = document.getElementById('btn-next');
                btn.innerText = "Done";
                btn.classList.remove('btn-secondary');
                btn.disabled = true;
                return;
            }
            
            isAnimating = true;
            currentStepIndex++;
            
            const targetNodeIdx = FILL_ORDER[currentStepIndex];
            const targetNode = nodeMeshes[targetNodeIdx];
            const targetData = NODES[targetNodeIdx];

            // Update Text
            document.getElementById('current-step').innerText = `Filling ${targetData.name}`;
            
            // Animate
            fillerParticle.visible = true;
            
            // Determine Start Position
            let startPos;
            if (currentStepIndex === 0) {
                startPos = new THREE.Vector3(2, 2, 0);
            } else {
                startPos = nodeMeshes[FILL_ORDER[currentStepIndex-1]].position.clone();
            }

            const endPos = targetNode.position.clone();
            
            // Draw persistent history line
            if (currentStepIndex > 0) {
                 const points = [startPos, endPos];
                 const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                 const lineMat = new THREE.LineBasicMaterial({ color: 0xffaaaa, transparent: true, opacity: 0.5 });
                 const line = new THREE.Line(lineGeo, lineMat);
                 scene.add(line);
            }

            // Animation Tween
            new TWEEN.Tween(startPos)
                .to(endPos, 1000) // 1 second travel
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate(() => {
                    fillerParticle.position.copy(startPos);
                })
                .onComplete(() => {
                    // Impact!
                    targetNode.material = matFilled;
                    targetNode.scale.set(1.2, 1.2, 1.2);
                    new TWEEN.Tween(targetNode.scale)
                        .to({x:1, y:1, z:1}, 300)
                        .start();
                    
                    document.getElementById('electron-count').innerText = `${currentStepIndex + 1} Sub-shells Filled`;
                    
                    if(targetData.name === '4s') {
                        document.getElementById('current-step').innerHTML = "Filling 4s <br><span style='font-size:0.7em'>(Lower energy than 3d!)</span>";
                    }

                    isAnimating = false;

                    // Auto Play Logic
                    if(isAutoPlaying) {
                        autoPlayTimeout = setTimeout(processNextStep, 800); // Wait 0.8s before next
                    } else {
                        // If user hit pause during animation
                        const btn = document.getElementById('btn-next');
                        btn.innerText = "Resume Auto-Fill";
                        btn.classList.remove('btn-secondary');
                    }
                    
                    // Final Check
                    if(currentStepIndex >= FILL_ORDER.length - 1) {
                        isAutoPlaying = false;
                        const btn = document.getElementById('btn-next');
                        btn.innerText = "Done";
                        btn.disabled = true;
                    }
                })
                .start();
        }

        window.resetSim = function() {
            // Stop everything
            isAutoPlaying = false;
            if(autoPlayTimeout) clearTimeout(autoPlayTimeout);
            isAnimating = false;
            TWEEN.removeAll(); // Stop any running tweens

            currentStepIndex = -1;
            nodeMeshes.forEach(m => {
                m.material = matEmpty.clone(); // Reset material
                m.scale.set(1,1,1);
            });
            fillerParticle.visible = false;
            
            // Clear lines 
            scene.children = scene.children.filter(c => c.type !== 'Line');
            // Add back arrow group (if we had specific ones, here we just used scene for lines)
            
            document.getElementById('current-step').innerText = "Start";
            document.getElementById('electron-count').innerText = "0 Electrons Filled";
            
            const btn = document.getElementById('btn-next');
            btn.disabled = false;
            btn.innerText = "Start Auto-Fill";
            btn.classList.remove('btn-secondary');
        };


        // --- Render Loop ---
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            // Labels Position
            labels.forEach(lbl => {
                const tempV = lbl.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.display = 'none';
                } else {
                    lbl.element.style.display = 'block';
                    lbl.element.style.left = x + 'px';
                    lbl.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
  </template>

  <template id="model-hund-rule" data-source="3. Configuration & Filling - Hund rule.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chlorine Radical Electron Arrangement</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #f0f2f5 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #6c5ce7; /* Purple */
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            color: #2c3e50;
        }
        
        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #555;
            margin-bottom: 15px;
        }

        .status-display {
            background: #f1f2f6;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-family: monospace;
            font-size: 1.1rem;
            font-weight: bold;
            color: #6c5ce7;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: #dfe6e9;
            color: #2d3436;
        }
        .btn-primary {
            background: #6c5ce7;
            color: white;
            box-shadow: 0 4px 10px rgba(108, 92, 231, 0.3);
        }
        .btn-primary:hover { background: #5b4cc4; transform: translateY(-1px); }
        .btn-primary:active { transform: translateY(1px); }
        .btn-primary:disabled { background: #b2bec3; cursor: not-allowed; box-shadow: none; transform: none; }

        .btn-secondary:hover { background: #b2bec3; }

        /* 3D Labels */
        .box-label {
            position: absolute;
            font-weight: bold;
            font-size: 0.9rem;
            color: #555;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        
        .radical-label {
            position: absolute;
            background: #e17055;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none; /* Hidden initially */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .radical-label::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #e17055 transparent transparent transparent;
        }

    </style>
    <!-- Updated Import Map for Stability -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>Chlorine Radical</h1>
            <p>
                Visualizing the orbital box diagram for Chlorine (Cl). Note the unpaired electron in the 3p orbital.
            </p>
            
            <div class="status-display" id="electron-config">
                1s<sup>0</sup>
            </div>

            <div class="controls">
                <button class="btn btn-primary" id="btn-add" onclick="toggleAutoFill()">Start Auto-Fill</button>
                <button class="btn btn-secondary" onclick="resetSim()">Reset</button>
            </div>
            
            <p style="margin-top: 15px; font-size: 0.8rem; font-style: italic; color: #888;">
                Total Electrons: <span id="e-count">0</span> / 17
            </p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import TWEEN from 'https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.min.js';

        // --- Configuration ---
        const TOTAL_ELECTRONS = 17; // Chlorine
        
        // Define Box Positions (x, y, z)
        // Stacking vertically by Energy Level
        // Boxes in p-orbitals are side-by-side
        const BOXES = [
            { id: '1s', n: 1, l: 's', idx: 0, pos: [0, -6, 0] },
            
            { id: '2s', n: 2, l: 's', idx: 0, pos: [0, -3.5, 0] },
            { id: '2p', n: 2, l: 'p', idx: 0, pos: [-1.2, -1, 0] },
            { id: '2p', n: 2, l: 'p', idx: 1, pos: [0, -1, 0] },
            { id: '2p', n: 2, l: 'p', idx: 2, pos: [1.2, -1, 0] },
            
            { id: '3s', n: 3, l: 's', idx: 0, pos: [0, 1.5, 0] },
            { id: '3p', n: 3, l: 'p', idx: 0, pos: [-1.2, 4, 0] },
            { id: '3p', n: 3, l: 'p', idx: 1, pos: [0, 4, 0] },
            { id: '3p', n: 3, l: 'p', idx: 2, pos: [1.2, 4, 0] }
        ];

        // Filling Order Logic (Index in BOXES array)
        const FILL_SEQUENCE = [
            { box: 0, spin: 'up' }, { box: 0, spin: 'down' }, // 1s (2)
            { box: 1, spin: 'up' }, { box: 1, spin: 'down' }, // 2s (4)
            
            // 2p (Hunds Rule)
            { box: 2, spin: 'up' }, { box: 3, spin: 'up' }, { box: 4, spin: 'up' }, 
            { box: 2, spin: 'down' }, { box: 3, spin: 'down' }, { box: 4, spin: 'down' }, // (10)
            
            { box: 5, spin: 'up' }, { box: 5, spin: 'down' }, // 3s (12)
            
            // 3p (Hunds Rule) - Need 5 electrons
            { box: 6, spin: 'up' }, { box: 7, spin: 'up' }, { box: 8, spin: 'up' }, 
            { box: 6, spin: 'down' }, { box: 7, spin: 'down' } // (17) -> 3p5
        ];

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xffffff, 20, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, -1, 0);

        // --- Lights ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(5, 10, 10);
        scene.add(dirLight);

        // --- Scene Construction ---
        
        const boxGroup = new THREE.Group();
        const arrowGroup = new THREE.Group();
        scene.add(boxGroup);
        scene.add(arrowGroup);

        // Materials
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const boxEdges = new THREE.EdgesGeometry(boxGeo);
        const boxMat = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
        const boxFillMat = new THREE.MeshBasicMaterial({ color: 0xf1f2f6, transparent: true, opacity: 0.2 });

        // Build Boxes
        const boxMeshes = [];
        const labels = [];
        
        BOXES.forEach((b, i) => {
            const group = new THREE.Group();
            group.position.set(...b.pos);
            
            // Wireframe box
            const lines = new THREE.LineSegments(boxEdges, boxMat);
            const fill = new THREE.Mesh(boxGeo, boxFillMat);
            group.add(lines, fill);
            
            boxGroup.add(group);
            boxMeshes.push(group);

            // Add Labels (Only for the first box of a subshell)
            if (i === 0 || BOXES[i-1].id !== b.id) {
                const el = document.createElement('div');
                el.className = 'box-label';
                el.innerText = b.id;
                labelsContainer.appendChild(el);
                // Position label to the left of the group (or the first box in group)
                labels.push({ element: el, pos: new THREE.Vector3(b.pos[0] - 1.0, b.pos[1], 0) });
            }
        });

        // Radical Label (Special)
        const radicalLabel = document.createElement('div');
        radicalLabel.className = 'radical-label';
        radicalLabel.innerText = "Unpaired Electron (Radical)";
        labelsContainer.appendChild(radicalLabel);
        
        // Arrow Geometry (Half-arrow)
        function createElectronArrow(color) {
            const group = new THREE.Group();
            
            // Shaft
            const shaft = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8),
                new THREE.MeshStandardMaterial({ color: color })
            );
            
            // Head (Half-head style typical in chem diagrams, but full cone is clearer in 3D)
            const head = new THREE.Mesh(
                new THREE.ConeGeometry(0.15, 0.3, 8),
                new THREE.MeshStandardMaterial({ color: color })
            );
            head.position.y = 0.4;
            
            group.add(shaft, head);
            return group;
        }

        // --- Animation Logic ---
        
        let electronCount = 0;
        const electrons = [];
        let isAutoFilling = false;
        let autoFillTimeout = null;

        window.toggleAutoFill = function() {
            if (electronCount >= TOTAL_ELECTRONS) return;

            isAutoFilling = !isAutoFilling;
            const btn = document.getElementById('btn-add');

            if (isAutoFilling) {
                btn.innerText = "Pause";
                btn.classList.add('btn-secondary');
                // Start the process
                processNextElectron();
            } else {
                btn.innerText = "Resume Auto-Fill";
                btn.classList.remove('btn-secondary');
                if(autoFillTimeout) clearTimeout(autoFillTimeout);
            }
        };

        function processNextElectron() {
            if (electronCount >= TOTAL_ELECTRONS) {
                isAutoFilling = false;
                const btn = document.getElementById('btn-add');
                btn.innerText = "Complete";
                btn.classList.remove('btn-secondary');
                btn.disabled = true;
                highlightRadical();
                return;
            }

            const step = FILL_SEQUENCE[electronCount];
            const targetBox = boxMeshes[step.box];
            const isUp = step.spin === 'up';

            // Create Electron
            const color = 0x2d3436; 
            const electron = createElectronArrow(color);
            
            // Start Position (Below the screen)
            electron.position.set(0, -10, 0); 
            
            // Target Position relative to box
            const offsetX = isUp ? -0.2 : 0.2;
            if (!isUp) electron.rotation.z = Math.PI;

            // Add to scene
            arrowGroup.add(electron);

            // Calculate world target
            const targetPos = targetBox.position.clone();
            targetPos.x += offsetX;
            
            // Animate
            new TWEEN.Tween(electron.position)
                .to(targetPos, 500) // Faster animation for auto-fill
                .easing(TWEEN.Easing.Back.Out)
                .onComplete(() => {
                    electronCount++;
                    document.getElementById('e-count').innerText = electronCount;
                    updateConfigDisplay();
                    
                    if (electronCount < TOTAL_ELECTRONS) {
                        if (isAutoFilling) {
                            autoFillTimeout = setTimeout(processNextElectron, 400); // Wait 400ms before next
                        }
                    } else {
                        // Finished
                        const btn = document.getElementById('btn-add');
                        btn.innerText = "Complete";
                        btn.classList.remove('btn-secondary');
                        btn.disabled = true;
                        highlightRadical();
                        isAutoFilling = false;
                    }
                })
                .start();
                
            electrons.push(electron);
        }

        function updateConfigDisplay() {
            let str = "";
            if (electronCount >= 2) str += "1s<sup>2</sup> ";
            else if (electronCount >= 1) str += "1s<sup>1</sup> ";
            
            if (electronCount >= 4) str += "2s<sup>2</sup> ";
            else if (electronCount >= 3) str += "2s<sup>1</sup> ";
            
            if (electronCount >= 10) str += "2p<sup>6</sup> ";
            else if (electronCount > 4) str += `2p<sup>${electronCount-4}</sup> `;
            
            if (electronCount >= 12) str += "3s<sup>2</sup> ";
            else if (electronCount > 10) str += `3s<sup>${electronCount-10}</sup> `;

            if (electronCount > 12) str += `3p<sup>${electronCount-12}</sup>`;

            document.getElementById('electron-config').innerHTML = str || "1s<sup>0</sup>";
        }

        function highlightRadical() {
            // Box 8 has ONLY Up. That is the radical.
            const radicalBox = boxMeshes[8];
            
            // Highlight Box
            const fillMesh = radicalBox.children[1];
            new TWEEN.Tween(fillMesh.material)
                .to({ opacity: 0.6, color: 0xff7675 }, 500)
                .start();
            
            // Show Label
            const targetPos = radicalBox.position.clone();
            targetPos.y += 1.0;
            
            radicalLabel.style.display = 'block';
            labels.push({ element: radicalLabel, pos: targetPos });
        }

        window.resetSim = function() {
            isAutoFilling = false;
            if(autoFillTimeout) clearTimeout(autoFillTimeout);
            TWEEN.removeAll();

            // Remove all electrons
            electrons.forEach(e => arrowGroup.remove(e));
            electrons.length = 0;
            electronCount = 0;
            
            // Reset Box Colors
            boxMeshes.forEach(g => {
                const fill = g.children[1];
                fill.material.opacity = 0.2;
                fill.material.color.setHex(0xf1f2f6);
            });
            
            // Reset UI
            document.getElementById('e-count').innerText = "0";
            document.getElementById('electron-config').innerHTML = "1s<sup>0</sup>";
            
            const btn = document.getElementById('btn-add');
            btn.disabled = false;
            btn.innerText = "Start Auto-Fill";
            btn.classList.remove('btn-secondary');
            
            // Hide Radical Label
            radicalLabel.style.display = 'none';
            const idx = labels.findIndex(l => l.element === radicalLabel);
            if (idx > -1) labels.splice(idx, 1);
        };

        // --- Animation Loop ---
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            // Labels Position
            labels.forEach(lbl => {
                const tempV = lbl.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.display = 'none';
                } else {
                    lbl.element.style.display = 'block';
                    lbl.element.style.left = x + 'px';
                    lbl.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
  </template>

  <template id="model-ground-state" data-source="3. Configuration & Filling - ground state.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Shell Energy Levels</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: linear-gradient(to bottom, #fdfbfb 0%, #ebedee 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 350px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #6c5ce7;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.5rem;
            color: #2d3436;
        }
        
        .info-text {
            font-size: 0.95rem;
            line-height: 1.6;
            color: #636e72;
            margin-bottom: 15px;
        }

        .highlight-box {
            background: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
            display: none; /* Hidden by default */
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            background: #6c5ce7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 4px 6px rgba(108, 92, 231, 0.2);
        }
        .btn:hover {
            background: #5b4cc4;
            transform: translateY(-2px);
        }
        .btn-outline {
            background: white;
            color: #6c5ce7;
            border: 2px solid #6c5ce7;
        }
        .btn-outline:hover {
            background: #f0f0ff;
        }

        /* 3D Labels */
        .level-label {
            position: absolute;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(255,255,255,0.8);
            pointer-events: none;
            color: #2d3436;
            transform: translate(-50%, -50%);
        }
        
        .axis-label {
            position: absolute;
            font-size: 12px;
            color: #b2bec3;
            font-weight: bold;
            letter-spacing: 1px;
            pointer-events: none;
        }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>Energy Levels</h1>
            <p class="info-text">
                Visualizing the Aufbau principle. Sub-shells are arranged by energy (vertical axis) and type (horizontal axis).
            </p>
            
            <div class="info-text" style="font-size: 0.85rem;">
                <strong>Key Color Code:</strong><br>
                <span style="color: #2d3436;">‚óè n=1</span> &nbsp;
                <span style="color: #27ae60;">‚óè n=2</span> &nbsp;
                <span style="color: #2980b9;">‚óè n=3</span> &nbsp;
                <span style="color: #c0392b;">‚óè n=4</span>
            </div>

            <div id="overlap-info" class="highlight-box">
                <strong>‚ö†Ô∏è Anomaly Detected!</strong><br>
                Notice that the <b>4s</b> sub-shell is lower in energy than the <b>3d</b> sub-shell. This is why 4s fills before 3d.
            </div>

            <div class="controls">
                <button class="btn" onclick="toggleOverlap()">Show Overlap</button>
                <button class="btn btn-outline" onclick="resetView()">Reset View</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Data ---
        // Energy units are arbitrary relative heights
        const SUBSHELLS = [
            { name: '1s', n: 1, type: 0, energy: 1, cap: 2, color: 0x2d3436 },
            
            { name: '2s', n: 2, type: 0, energy: 4, cap: 2, color: 0x27ae60 },
            { name: '2p', n: 2, type: 1, energy: 5, cap: 6, color: 0x27ae60 },
            
            { name: '3s', n: 3, type: 0, energy: 8, cap: 2, color: 0x2980b9 },
            { name: '3p', n: 3, type: 1, energy: 9, cap: 6, color: 0x2980b9 },
            { name: '3d', n: 3, type: 2, energy: 13, cap: 10, color: 0x2980b9 }, // Higher than 4s
            
            { name: '4s', n: 4, type: 0, energy: 11, cap: 2, color: 0xc0392b }, // Lower than 3d
            { name: '4p', n: 4, type: 1, energy: 14, cap: 6, color: 0xc0392b },
            { name: '4d', n: 4, type: 2, energy: 17, cap: 10, color: 0xc0392b },
            { name: '4f', n: 4, type: 3, energy: 20, cap: 14, color: 0xc0392b },
            
            { name: '5s', n: 5, type: 0, energy: 16, cap: 2, color: 0x2d3436 } // Just for context
        ];

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();
        // Light fog for depth
        scene.fog = new THREE.Fog(0xebedee, 20, 60);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(20, 15, 30); // Isometric-ish view

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(5, 10, 0);

        // --- Lighting ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 30, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- Grid/Floor ---
        const gridHelper = new THREE.GridHelper(30, 30, 0xbdc3c7, 0xe0e0e0);
        scene.add(gridHelper);

        // --- Axis Labels in 3D ---
        // (Handled by simple HTML overlays or just implied by structure)
        
        // --- Building the Energy Levels ---
        const platforms = [];
        const electrons = [];
        const labels = [];
        
        // Geometry for platforms
        const platWidth = 3;
        const platDepth = 3;
        const platHeight = 0.2;
        const platGeo = new THREE.BoxGeometry(platWidth, platHeight, platDepth);

        // Electron Geometry
        const eGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const eMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.5 });

        // Overlap Indicator Line
        let overlapLine;

        function buildScene() {
            SUBSHELLS.forEach(sub => {
                // Position logic
                // X axis: Subshell Type (s=0, p=1, d=2, f=3) -> Spacing of 5 units
                const x = sub.type * 5; 
                // Y axis: Energy
                const y = sub.energy * 1.5; 
                // Z axis: Slightly staggered for style or kept flat? Let's keep flat Z=0
                const z = 0;

                // 1. Platform
                const material = new THREE.MeshStandardMaterial({ 
                    color: sub.color, 
                    transparent: true, 
                    opacity: 0.9,
                    roughness: 0.3
                });
                const mesh = new THREE.Mesh(platGeo, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                platforms.push({ mesh, data: sub });

                // 2. Connector Line (Stalk) to ground
                const stalkGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, 0, z), new THREE.Vector3(x, y, z)]);
                const stalkMat = new THREE.LineBasicMaterial({ color: 0xbdc3c7, opacity: 0.4, transparent: true });
                const stalk = new THREE.Line(stalkGeo, stalkMat);
                scene.add(stalk);

                // 3. Electrons (Visualizing Capacity)
                // Arrange them in a circle or grid on top of platform
                const radius = 1.0;
                for(let i=0; i<sub.cap; i++) {
                    const angle = (i / sub.cap) * Math.PI * 2;
                    // For single electron, center it. For 2, put side by side.
                    let ex = x, ez = z;
                    
                    if (sub.cap === 2) {
                        ex = x + (i===0 ? -0.5 : 0.5);
                    } else {
                        ex = x + Math.cos(angle) * radius;
                        ez = z + Math.sin(angle) * radius;
                    }
                    
                    const eMesh = new THREE.Mesh(eGeo, eMat);
                    eMesh.position.set(ex, y + 0.4, ez);
                    eMesh.castShadow = true;
                    scene.add(eMesh);
                    electrons.push({ mesh: eMesh, oy: y + 0.4 }); // Store original Y for animation
                }

                // 4. Create HTML Label
                const labelEl = document.createElement('div');
                labelEl.className = 'level-label';
                labelEl.innerHTML = `<span style="font-size:1.2em">${sub.name}</span><br><span style="font-size:0.8em; opacity:0.7">${sub.cap}e‚Åª</span>`;
                labelEl.style.color = '#' + sub.color.toString(16).padStart(6, '0'); // Match platform color
                labelsContainer.appendChild(labelEl);
                labels.push({ element: labelEl, position: new THREE.Vector3(x, y + 1.5, z) });
            });

            // Create Overlap Line (Hidden initially)
            // Connecting 4s and 3d
            const s4 = platforms.find(p => p.data.name === '4s');
            const d3 = platforms.find(p => p.data.name === '3d');
            
            if(s4 && d3) {
                const points = [
                    s4.mesh.position.clone(),
                    d3.mesh.position.clone()
                ];
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineDashedMaterial({ color: 0xe74c3c, dashSize: 0.5, gapSize: 0.2, linewidth: 2 });
                overlapLine = new THREE.Line(geo, mat);
                overlapLine.computeLineDistances();
                overlapLine.visible = false;
                scene.add(overlapLine);
            }
        }
        
        buildScene();
        
        // Add Floor labels (s, p, d, f)
        const types = ['s', 'p', 'd', 'f'];
        types.forEach((t, i) => {
            const el = document.createElement('div');
            el.className = 'axis-label';
            el.innerText = `SUB-SHELL ${t.toUpperCase()}`;
            labelsContainer.appendChild(el);
            labels.push({ 
                element: el, 
                position: new THREE.Vector3(i * 5, 0.1, 3.5) // Front of the column
            });
        });


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.002;

            // Bobbing electrons
            electrons.forEach((e, i) => {
                e.mesh.position.y = e.oy + Math.sin(time + i) * 0.1;
            });

            // Update Labels
            labels.forEach(lbl => {
                const tempV = lbl.position.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.display = 'none';
                } else {
                    lbl.element.style.display = 'block';
                    lbl.element.style.left = x + 'px';
                    lbl.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // --- Interaction ---
        let showOverlap = false;
        
        window.toggleOverlap = function() {
            showOverlap = !showOverlap;
            overlapLine.visible = showOverlap;
            
            const box = document.getElementById('overlap-info');
            box.style.display = showOverlap ? 'block' : 'none';

            if(showOverlap) {
                // Move camera to best viewing angle
                // We want to see 4s vs 3d side view
                const startPos = camera.position.clone();
                const targetPos = new THREE.Vector3(8, 12, 25); // Side view
                
                // Simple lerp animation could go here, but instant is fine for this tool
                // Let's just set it
                // camera.position.copy(targetPos);
                // controls.target.set(5, 12, 0);
            }
        };

        window.resetView = function() {
            camera.position.set(20, 15, 30);
            controls.target.set(5, 10, 0);
            showOverlap = false;
            overlapLine.visible = false;
            document.getElementById('overlap-info').style.display = 'none';
        };

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
  </template>

  <template id="model-spin" data-source="3. Configuration & Filling- Spin.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electron Spin</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, #ffffff 0%, #f0f2f5 100%);
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 5px solid #0984e3; /* Blue */
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            color: #2c3e50;
        }
        
        p {
            font-size: 0.9rem;
            line-height: 1.5;
            color: #555;
            margin-bottom: 15px;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: #dfe6e9;
            color: #2d3436;
        }
        .btn:hover { background: #b2bec3; }
        .btn.active {
            background: #0984e3;
            color: white;
        }

        /* 3D Labels */
        .spin-label {
            position: absolute;
            background: rgba(255,255,255,0.9);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: bold;
            color: #2d3436;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: 1px solid #ddd;
            text-align: center;
        }
        .pole-label {
            position: absolute;
            font-weight: bold;
            font-size: 1.5rem;
            pointer-events: none;
            text-shadow: 0 0 5px white;
        }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>Electron Spin</h1>
            <p>
                Electrons have an intrinsic property called "spin". They behave like tiny magnets with North and South poles.
            </p>
            <p style="font-size: 0.85rem; color: #888;">
                Opposite spins allow two electrons to occupy the same orbital (Pauli Exclusion Principle).
            </p>
            
            <div class="controls">
                <button class="btn active" id="btn-spin" onclick="toggleSpin()">Pause Spin</button>
                <button class="btn active" id="btn-axis" onclick="toggleAxis()">Hide Axis</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xffffff, 20, 60);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Lights ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 10);
        scene.add(dirLight);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(-5, -5, -10);
        scene.add(backLight);

        // --- Objects ---
        const electrons = [];
        const axisGroup = new THREE.Group();
        scene.add(axisGroup);

        // Materials
        const sphereGeo = new THREE.SphereGeometry(2.5, 32, 32);
        const sphereMat = new THREE.MeshStandardMaterial({ 
            color: 0x74b9ff, // Light Blue
            roughness: 0.2,
            metalness: 0.1
        });
        
        // Ring for equator (to visualize spin)
        const ringGeo = new THREE.TorusGeometry(2.55, 0.05, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x2d3436 });
        
        // Arrow Helper Function
        function createAxisArrow(length, color) {
            // Shaft
            const shaftGeo = new THREE.CylinderGeometry(0.08, 0.08, length, 12);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const shaft = new THREE.Mesh(shaftGeo, mat);
            shaft.position.y = length / 2;
            
            // Head
            const headGeo = new THREE.ConeGeometry(0.3, 0.8, 12);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.y = length;
            
            const group = new THREE.Group();
            group.add(shaft, head);
            return group;
        }

        // --- Create Electron Function ---
        function createElectron(xPos, spinUp) {
            const group = new THREE.Group();
            group.position.x = xPos;
            scene.add(group);

            // 1. The Sphere
            const sphere = new THREE.Mesh(sphereGeo, sphereMat);
            group.add(sphere);

            // 2. Visual Features for Spin
            // Add stripes/features to the sphere so we can see it rotating
            const stripeGeo = new THREE.BoxGeometry(5.2, 0.2, 0.2); // Stick going through
            const stripe = new THREE.Mesh(stripeGeo, new THREE.MeshBasicMaterial({ color: 0x0984e3 }));
            sphere.add(stripe); // Child of sphere so it rotates with it
            
            const stripe2 = stripe.clone();
            stripe2.rotation.y = Math.PI / 2;
            sphere.add(stripe2);
            
            // Equator Ring
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            sphere.add(ring);
            
            // Minus Sign
            const minusGeo = new THREE.BoxGeometry(1.5, 0.3, 0.1);
            const minusMat = new THREE.MeshBasicMaterial({ color: 0x2d3436 });
            const minus = new THREE.Mesh(minusGeo, minusMat);
            minus.position.z = 2.5; // On surface
            sphere.add(minus);

            // 3. Magnetic Axis (The Arrow)
            const arrowLen = 7;
            const arrowColor = 0xd63031; // Red
            const arrowGroupLocal = new THREE.Group();
            
            // Up Arrow
            const upArr = createAxisArrow(3.5, arrowColor);
            upArr.position.y = 2.5;
            arrowGroupLocal.add(upArr);
            
            // Down Arrow (Tail) - Actually just a line down
            const downShaft = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 3.5, 12),
                new THREE.MeshBasicMaterial({ color: arrowColor })
            );
            downShaft.position.y = -2.5 - 1.75; // Adjust
            arrowGroupLocal.add(downShaft);

            if (!spinUp) {
                arrowGroupLocal.rotation.x = Math.PI; // Flip the magnet
            }
            
            group.add(arrowGroupLocal);
            axisGroup.add(arrowGroupLocal); // Keep ref for toggling

            // 4. Curved Arrow (Spin Direction Indicator)
            // Just a visual torus arc
            const curveGroup = new THREE.Group();
            const curveGeo = new THREE.TorusGeometry(3.5, 0.1, 8, 50, Math.PI); // Half circle
            const curveMat = new THREE.MeshBasicMaterial({ color: 0x2d3436 });
            const curve = new THREE.Mesh(curveGeo, curveMat);
            curve.rotation.x = Math.PI/2;
            curveGroup.add(curve);
            
            // Arrow head for curve
            const coneGeo = new THREE.ConeGeometry(0.3, 0.6, 12);
            const cone = new THREE.Mesh(coneGeo, new THREE.MeshBasicMaterial({ color: 0x2d3436 }));
            
            if(spinUp) {
                // Clockwise-ish visual
                cone.position.set(3.5, 0, 0); 
                cone.rotation.x = Math.PI/2;
            } else {
                // Counter-clockwise
                cone.position.set(-3.5, 0, 0);
                cone.rotation.x = -Math.PI/2;
                curve.rotation.z = Math.PI; // Flip curve
            }
            curveGroup.add(cone);
            
            group.add(curveGroup);
            
            // Store for animation
            electrons.push({
                mesh: sphere,
                spinUp: spinUp,
                speed: spinUp ? -0.05 : 0.05
            });

            return group;
        }

        createElectron(-4, true);  // Left: Spin Up
        createElectron(4, false);  // Right: Spin Down

        // --- Labels ---
        const labels = [
            { text: "Clockwise Spin", sub: "+1/2", pos: new THREE.Vector3(-4, -4.5, 0) },
            { text: "Anti-clockwise Spin", sub: "-1/2", pos: new THREE.Vector3(4, -4.5, 0) },
            
            { text: "N", type: 'pole', pos: new THREE.Vector3(-4, 6.5, 0), color: '#d63031' },
            { text: "S", type: 'pole', pos: new THREE.Vector3(-4, -6.5, 0), color: '#333' },
            
            { text: "S", type: 'pole', pos: new THREE.Vector3(4, 6.5, 0), color: '#333' },
            { text: "N", type: 'pole', pos: new THREE.Vector3(4, -6.5, 0), color: '#d63031' }
        ];

        const htmlLabels = [];
        labels.forEach(l => {
            const el = document.createElement('div');
            if (l.type === 'pole') {
                el.className = 'pole-label';
                el.style.color = l.color;
            } else {
                el.className = 'spin-label';
                el.innerHTML = `${l.text}<br><span style="font-size:0.8em; color:#888">${l.sub}</span>`;
            }
            el.innerText = l.type === 'pole' ? l.text : undefined;
            labelsContainer.appendChild(el);
            htmlLabels.push({ element: el, pos: l.pos });
        });

        // --- Animation Loop ---
        let isSpinning = true;
        let showAxis = true;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (isSpinning) {
                electrons.forEach(e => {
                    e.mesh.rotation.y += e.speed;
                });
            }

            // Update Labels
            htmlLabels.forEach(lbl => {
                const tempV = lbl.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.display = 'none';
                } else {
                    lbl.element.style.display = 'block';
                    lbl.element.style.left = x + 'px';
                    lbl.element.style.top = y + 'px';
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // --- UI Functions ---
        window.toggleSpin = function() {
            isSpinning = !isSpinning;
            const btn = document.getElementById('btn-spin');
            btn.innerText = isSpinning ? "Pause Spin" : "Resume Spin";
            btn.classList.toggle('active');
        };

        window.toggleAxis = function() {
            showAxis = !showAxis;
            axisGroup.visible = showAxis;
            const btn = document.getElementById('btn-axis');
            btn.innerText = showAxis ? "Hide Axis" : "Show Axis";
            btn.classList.toggle('active');
            
            // Toggle Pole Labels too
            const poles = document.querySelectorAll('.pole-label');
            poles.forEach(p => p.style.display = showAxis ? 'block' : 'none');
        };

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
  </template>

  <template id="model-electric-field" data-source="Behavior in Electric Field.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subatomic Particles in Electric Field</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            color: #333;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            pointer-events: none;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border-left: 6px solid #4a90e2;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.3rem;
            color: #2c3e50;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 15px 0;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            background: #e9ecef;
            color: #495057;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover { background: #dee2e6; }
        .btn.active { background: #4a90e2; color: white; }

        .slider-container {
            margin-top: 15px;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }
        input[type=range] {
            width: 100%;
        }

        /* Labels in 3D space */
        .plate-label {
            position: absolute;
            background: rgba(255,255,255,0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            pointer-events: none;
            border: 1px solid #ddd;
            transform: translate(-50%, -50%);
        }
        .plate-label.pos { color: #d35400; border-color: #e67e22; background: #fdf2e9; }
        .plate-label.neg { color: #2c3e50; border-color: #34495e; background: #ebf5fb; }

    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="labels-container"></div>

    <div id="ui-layer">
        <div class="card">
            <h1>Deflection in Electric Field</h1>
            <p style="font-size: 0.9rem; color: #555; margin-bottom: 0;">
                Particles are passing between charged plates. Observe how mass and charge affect the path.
            </p>

            <div class="legend">
                <div class="legend-item">
                    <span class="dot" style="background: #e74c3c;"></span> 
                    Electron (Light, Negative)
                </div>
                <div class="legend-item">
                    <span class="dot" style="background: #2ecc71;"></span> 
                    Neutron (Neutral)
                </div>
                <div class="legend-item">
                    <span class="dot" style="background: #3498db;"></span> 
                    Proton (Heavy, Positive)
                </div>
            </div>

            <div class="slider-container">
                <div class="slider-label"><span>Simulation Speed</span> <span id="speed-val">100%</span></div>
                <input type="range" id="speed-slider" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="controls">
                <button class="btn active" id="btn-trails" onclick="toggleTrails()">Show Trails</button>
                <button class="btn" onclick="resetParticles()">Reset Beam</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const labelsContainer = document.getElementById('labels-container');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f2f5);
        scene.fog = new THREE.Fog(0xf0f2f5, 20, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(5, 0, 0); // Look at center of plates

        // --- Lighting ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(-5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- Environment Objects ---
        
        // 1. Particle Emitter (The "Gun")
        const gunGeo = new THREE.BoxGeometry(2, 2, 2);
        const gunMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const gun = new THREE.Mesh(gunGeo, gunMat);
        gun.position.set(-10, 0, 0);
        scene.add(gun);

        const barrelGeo = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
        const barrel = new THREE.Mesh(barrelGeo, gunMat);
        barrel.rotation.z = -Math.PI / 2;
        barrel.position.set(-8.5, 0, 0);
        scene.add(barrel);

        // 2. Charged Plates
        const plateGeo = new THREE.BoxGeometry(16, 0.5, 6);
        
        // Top Plate (+)
        const topPlateMat = new THREE.MeshStandardMaterial({ color: 0xffeebb, transparent: true, opacity: 0.9 }); // Orange tint
        const topPlate = new THREE.Mesh(plateGeo, topPlateMat);
        topPlate.position.set(2, 3, 0);
        scene.add(topPlate);

        // Bottom Plate (-)
        const botPlateMat = new THREE.MeshStandardMaterial({ color: 0xd6eaf8, transparent: true, opacity: 0.9 }); // Blue tint
        const botPlate = new THREE.Mesh(plateGeo, botPlateMat);
        botPlate.position.set(2, -3, 0);
        scene.add(botPlate);

        // Field Lines (Visual Aid)
        const fieldGroup = new THREE.Group();
        for(let x = -5; x < 9; x+=2) {
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, 2.5, 0), new THREE.Vector3(x, -2.5, 0)]);
            const lineMat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 0.3, gapSize: 0.3 });
            const line = new THREE.Line(lineGeo, lineMat);
            line.computeLineDistances();
            fieldGroup.add(line);
        }
        scene.add(fieldGroup);

        // --- Labels ---
        function createLabel(text, type, pos) {
            const el = document.createElement('div');
            el.className = `plate-label ${type}`;
            el.textContent = text;
            labelsContainer.appendChild(el);
            return { element: el, position: pos };
        }
        const labels = [
            createLabel("Positive Plate (+)", "pos", new THREE.Vector3(2, 3.8, 2)),
            createLabel("Negative Plate (-)", "neg", new THREE.Vector3(2, -3.8, 2)),
            createLabel("Beam Source", "neg", new THREE.Vector3(-10, 1.5, 0))
        ];

        // --- Particle System ---
        
        const PARTICLES = [];
        const MAX_PARTICLES = 100; // Limit for performance
        let showTrails = true;
        let simSpeed = 1.0;

        const pGeo = new THREE.SphereGeometry(0.15, 16, 16);
        const matElectron = new THREE.MeshBasicMaterial({ color: 0xe74c3c }); // Red
        const matProton = new THREE.MeshBasicMaterial({ color: 0x3498db });   // Blue
        const matNeutron = new THREE.MeshBasicMaterial({ color: 0x2ecc71 });  // Green

        class Particle {
            constructor(type) {
                this.type = type;
                this.mesh = new THREE.Mesh(pGeo, 
                    type === 'e' ? matElectron : 
                    type === 'p' ? matProton : matNeutron
                );
                
                // Physics properties based on diagram
                // Electron: fast deflect up. Proton: slow deflect down. Neutron: straight.
                this.mass = type === 'e' ? 1 : 15; // Proton much heavier
                this.charge = type === 'e' ? 1 : type === 'p' ? -1 : 0; // Direction multiplier (+1 goes up, -1 goes down)
                
                // Trail
                this.trailPoints = [];
                this.trailLine = null;
                
                this.reset();
                scene.add(this.mesh);
            }

            reset() {
                this.mesh.position.set(-9, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5); // Start at gun with slight spread
                this.velocity = new THREE.Vector3(0.15, 0, 0); // Constant horizontal speed
                this.active = true;
                
                // Clear trail
                if(this.trailLine) {
                    scene.remove(this.trailLine);
                    this.trailLine = null;
                }
                this.trailPoints = [];
            }

            update(speedFactor) {
                if(!this.active) return;

                // Move X
                this.mesh.position.x += this.velocity.x * speedFactor;

                // Physics: Electric Field Effect
                // Only active between x = -6 and x = 10 (approx plate length)
                if (this.mesh.position.x > -6 && this.mesh.position.x < 10) {
                    // Force = Charge * FieldStrength
                    // Acceleration = Force / Mass
                    // Simplified: accelY = (ChargeDir * Constant) / Mass
                    
                    const fieldStrength = 0.008;
                    const accelY = (this.charge * fieldStrength) / this.mass;
                    
                    this.velocity.y += accelY * speedFactor;
                    this.mesh.position.y += this.velocity.y * speedFactor;
                } else {
                    // Continue straight after leaving field
                    this.mesh.position.y += this.velocity.y * speedFactor;
                }

                // Trail Logic
                if (showTrails) {
                    // Add point every few frames to save perf
                    if (this.mesh.position.x < 15) { // Stop drawing far out
                         this.trailPoints.push(this.mesh.position.clone());
                    }
                }

                // Recycle if too far
                if (this.mesh.position.x > 20 || Math.abs(this.mesh.position.y) > 10) {
                    this.active = false;
                    // Keep trail visible for a moment? For now just hide mesh
                    this.mesh.visible = false;
                } else {
                    this.mesh.visible = true;
                }
            }

            drawTrail() {
                if (!showTrails || this.trailPoints.length < 2) return;

                // Simple line update - remove old, add new (inefficient but simple for <100 lines)
                if(this.trailLine) scene.remove(this.trailLine);

                const geometry = new THREE.BufferGeometry().setFromPoints(this.trailPoints);
                const material = new THREE.LineBasicMaterial({ 
                    color: this.type === 'e' ? 0xffaaaa : this.type === 'p' ? 0xaaddff : 0xaaffaa,
                    opacity: 0.5,
                    transparent: true
                });
                
                this.trailLine = new THREE.Line(geometry, material);
                scene.add(this.trailLine);
            }
        }

        // --- Spawn Logic ---
        let spawnTimer = 0;
        
        function spawnParticles() {
            // Find inactive particle or create new
            // We want to spawn a mix.
            const types = ['e', 'e', 'p', 'p', 'n']; // Weighted slightly
            const type = types[Math.floor(Math.random() * types.length)];
            
            // Try reuse
            const inactive = PARTICLES.find(p => !p.active && p.type === type);
            if (inactive) {
                inactive.reset();
            } else if (PARTICLES.length < MAX_PARTICLES) {
                PARTICLES.push(new Particle(type));
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Spawning
            spawnTimer++;
            if(spawnTimer > 10) { // Spawn every 10 frames
                spawnParticles();
                spawnTimer = 0;
            }

            // Updating
            PARTICLES.forEach(p => {
                p.update(simSpeed);
                if(showTrails && p.active) p.drawTrail();
            });

            // Label Positioning
            labels.forEach(lbl => {
                const tempV = lbl.position.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * container.clientWidth;
                const y = (tempV.y * -.5 + .5) * container.clientHeight;

                if (Math.abs(tempV.z) > 1) {
                    lbl.element.style.display = 'none';
                } else {
                    lbl.element.style.display = 'block';
                    lbl.element.style.left = `${x}px`;
                    lbl.element.style.top = `${y}px`;
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // --- UI Controls ---
        window.toggleTrails = function() {
            showTrails = !showTrails;
            document.getElementById('btn-trails').classList.toggle('active');
            // Clear existing
            if(!showTrails) {
                PARTICLES.forEach(p => {
                    if(p.trailLine) {
                        scene.remove(p.trailLine);
                        p.trailLine = null;
                    }
                    p.trailPoints = [];
                });
            }
        };

        window.resetParticles = function() {
            PARTICLES.forEach(p => {
                p.active = false;
                p.mesh.visible = false;
                if(p.trailLine) {
                    scene.remove(p.trailLine);
                    p.trailLine = null;
                }
            });
        };

        const slider = document.getElementById('speed-slider');
        const speedVal = document.getElementById('speed-val');
        slider.addEventListener('input', (e) => {
            simSpeed = parseFloat(e.target.value);
            speedVal.innerText = Math.round(simSpeed * 100) + '%';
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
  </template>

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel" data-presets="env,react">
    const { useState } = React;

    const IconBase = ({ size = 24, strokeWidth = 2, className = '', children, fill = 'none' }) => (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width={size}
        height={size}
        viewBox="0 0 24 24"
        fill={fill}
        stroke="currentColor"
        strokeWidth={strokeWidth}
        strokeLinecap="round"
        strokeLinejoin="round"
        className={className}
      >
        {children}
      </svg>
    );

    const AtomIcon = (props) => (
      <IconBase {...props}>
        <circle cx="12" cy="12" r="1.5" />
        <ellipse cx="12" cy="12" rx="9" ry="4.5" />
        <ellipse cx="12" cy="12" rx="9" ry="4.5" transform="rotate(60 12 12)" />
        <ellipse cx="12" cy="12" rx="9" ry="4.5" transform="rotate(-60 12 12)" />
      </IconBase>
    );

    const ZapIcon = (props) => (
      <IconBase {...props}>
        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" fill="none" />
      </IconBase>
    );

    const CircleIcon = (props) => (
      <IconBase {...props}>
        <circle cx="12" cy="12" r="9" />
      </IconBase>
    );

    const SearchIcon = (props) => (
      <IconBase {...props}>
        <circle cx="11" cy="11" r="7" />
        <line x1="16.65" y1="16.65" x2="21" y2="21" />
      </IconBase>
    );

    const ArrowRightIcon = (props) => (
      <IconBase {...props}>
        <line x1="5" y1="12" x2="19" y2="12" />
        <polyline points="12 5 19 12 12 19" />
      </IconBase>
    );

    const RotateCcwIcon = (props) => (
      <IconBase {...props}>
        <polyline points="3 2 3 8 9 8" />
        <path d="M3 8a9 9 0 1 0 3-6.7" />
      </IconBase>
    );

    const CheckIcon = (props) => (
      <IconBase {...props}>
        <polyline points="20 6 9 17 4 12" />
      </IconBase>
    );

    const XIcon = (props) => (
      <IconBase {...props}>
        <line x1="18" y1="6" x2="6" y2="18" />
        <line x1="6" y1="6" x2="18" y2="18" />
      </IconBase>
    );

    const modelDocs = {
      structureAtom: document.getElementById('model-structure-atom')?.innerHTML || '',
      shellsSubshells: document.getElementById('model-shells-subshells')?.innerHTML || '',
      orbitalsHierarchy: document.getElementById('model-orbitals-hierarchy')?.innerHTML || '',
      orbitalsShapes: document.getElementById('model-orbitals-shapes')?.innerHTML || '',
      orbitalsExpansion: document.getElementById('model-orbitals-s-expansion')?.innerHTML || '',
      fillingOrder: document.getElementById('model-filling-order')?.innerHTML || '',
      hundRule: document.getElementById('model-hund-rule')?.innerHTML || '',
      groundState: document.getElementById('model-ground-state')?.innerHTML || '',
      spin: document.getElementById('model-spin')?.innerHTML || '',
      electricField: document.getElementById('model-electric-field')?.innerHTML || '',
    };

    const ModelViewer = ({ label, docKey, className = '' }) => {
      const [open, setOpen] = useState(false);
      const html = modelDocs[docKey];
      const containerClass = `my-4 ${className}`.trim();

      if (!html) return null;

      return (
        <div className={containerClass}>
          <button
            onClick={() => setOpen(true)}
            className="w-full bg-slate-900 text-white px-4 py-3 rounded-lg font-bold shadow-md hover:shadow-lg hover:bg-slate-800 transition flex items-center justify-center gap-2 uppercase text-xs tracking-[0.25em]"
          >
            <ZapIcon size={18} /> <span className="truncate">Launch 3D ‚Ä¢ {label}</span>
          </button>

          {open && (
            <div className="fixed inset-0 z-[9999] bg-slate-950/95 backdrop-blur-sm flex items-center justify-center p-6">
              <div
                className="relative bg-black shadow-2xl border border-white/10 rounded-lg overflow-hidden"
                style={{ width: 'min(calc(100vw - 48px), calc((100vh - 48px) * 4 / 3))', aspectRatio: '4 / 3' }}
              >
                <iframe
                  title={label}
                  srcDoc={html}
                  className="absolute inset-0 w-full h-full border-0 bg-black"
                  allowFullScreen
                />
                <div className="absolute top-2 left-2 right-2 flex items-center justify-between text-white">
                  <div className="font-bold text-[11px] md:text-sm uppercase tracking-[0.35em] bg-white/10 px-3 py-1 rounded">{label}</div>
                  <button
                    onClick={() => setOpen(false)}
                    className="flex items-center gap-2 px-3 py-2 rounded bg-white/15 hover:bg-white/25 text-white font-semibold uppercase text-[11px] tracking-widest shadow-lg border border-white/10"
                  >
                    <XIcon size={18} /> Close
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    const Fraction = ({ num, den }) => (
      <div className="inline-block align-middle text-center mx-1 text-sm font-mono">
        <span className="block border-b border-slate-800 px-1">{num}</span>
        <span className="block">{den}</span>
      </div>
    );

    const Power = ({ base, exp }) => (
      <span>
        {base}<sup className="text-xs font-bold">{exp}</sup>
      </span>
    );

    const SectionTitle = ({ children }) => (
      <h2 className="text-3xl md:text-4xl font-bold text-center text-slate-800 mb-8 header-font uppercase tracking-wide">
        {children}
      </h2>
    );

    const SubHeading = ({ children }) => (
      <h3 className="text-xl md:text-2xl font-bold text-slate-700 mt-8 mb-4 border-l-4 border-blue-600 pl-4 flex items-center gap-2 bg-slate-100 py-2 rounded-r-lg">
        {children}
      </h3>
    );

    const Point = ({ children }) => (
      <li className="mb-3 text-lg leading-relaxed text-slate-700 list-none flex items-start group">
        <span className="mr-3 mt-1 text-blue-600 font-bold text-sm">‚ñ∂</span>
        <div className="group-hover:text-slate-900 transition-colors">{children}</div>
      </li>
    );

    const Quiz = ({ questions }) => {
      const [currentQ, setCurrentQ] = useState(0);
      const [score, setScore] = useState(0);
      const [showScore, setShowScore] = useState(false);
      const [selected, setSelected] = useState(null);
      const [feedback, setFeedback] = useState('');

      const handleAnswer = (isCorrect, index) => {
        setSelected(index);
        if (isCorrect) {
          setScore(score + 1);
          setFeedback('CORRECT');
        } else {
          setFeedback('INCORRECT');
        }

        setTimeout(() => {
          const nextQ = currentQ + 1;
          if (nextQ < questions.length) {
            setCurrentQ(nextQ);
            setSelected(null);
            setFeedback('');
          } else {
            setShowScore(true);
          }
        }, 1500);
      };

      const resetQuiz = () => {
        setCurrentQ(0);
        setScore(0);
        setShowScore(false);
        setSelected(null);
        setFeedback('');
      };

      if (showScore) {
        return (
          <div className="bg-white p-8 rounded-lg shadow-xl text-center border-t-4 border-blue-600 animate-fade-in-up">
            <div className="text-6xl mb-4">üìä</div>
            <h3 className="text-2xl font-bold mb-4 text-slate-800 header-font">ASSESSMENT COMPLETE</h3>
            <p className="text-xl mb-6 text-slate-600 font-mono">SCORE: <span className="text-4xl font-bold text-blue-600 block mt-2">{score} / {questions.length}</span></p>
            <button onClick={resetQuiz} className="bg-slate-800 text-white px-8 py-3 rounded-md font-bold shadow-lg hover:bg-slate-700 transition transform hover:scale-105 flex items-center justify-center mx-auto gap-2 uppercase tracking-wider text-sm">
              <RotateCcwIcon size={18} /> Restart Module
            </button>
          </div>
        );
      }

      return (
        <div className="bg-white p-6 rounded-lg shadow-md border border-slate-200 my-8 animate-fade-in">
          <div className="flex justify-between items-center mb-6 border-b border-slate-100 pb-4">
            <span className="font-bold text-slate-400 text-xs tracking-widest uppercase font-mono">Question {currentQ + 1} / {questions.length}</span>
            <div className="bg-slate-100 text-slate-700 px-3 py-1 rounded font-bold text-xs font-mono border border-slate-200">PTS: {score}</div>
          </div>

          <div className="mb-6 h-1 w-full bg-slate-100 rounded-full overflow-hidden">
            <div className="h-full bg-blue-600 transition-all duration-500" style={{ width: `${((currentQ + 1) / questions.length) * 100}%` }}></div>
          </div>

          <h4 className="text-xl font-bold mb-6 text-slate-800 leading-snug header-font">{questions[currentQ].question}</h4>
          <div className="space-y-3">
            {questions[currentQ].options.map((opt, idx) => (
              <button
                key={idx}
                onClick={() => selected === null && handleAnswer(opt.correct, idx)}
                className={`w-full text-left p-4 rounded-md transition-all duration-200 border relative overflow-hidden ${
                  selected === idx
                    ? opt.correct ? 'bg-blue-50 border-blue-500 text-blue-900' : 'bg-red-50 border-red-500 text-red-900'
                    : 'bg-slate-50 border-slate-200 hover:bg-white hover:border-blue-400 hover:shadow-sm text-slate-700'
                }`}
                disabled={selected !== null}
              >
                <div className="flex justify-between items-center relative z-10">
                  <span className="font-medium">{opt.text}</span>
                  {selected === idx && (
                    opt.correct
                      ? <CheckIcon className="text-blue-700 font-bold" size={24} />
                      : <XIcon className="text-red-700 font-bold" size={24} />
                  )}
                </div>
              </button>
            ))}
          </div>
          {feedback && <div className={`mt-4 text-center font-bold text-sm font-mono tracking-widest uppercase ${feedback === 'CORRECT' ? 'text-green-600' : 'text-red-600'}`}>{feedback}</div>}
        </div>
      );
    };

    const AtomDiagram = () => (
      <div className="flex justify-center my-8 p-4 bg-white rounded-lg shadow-sm border border-slate-200">
        <svg viewBox="0 0 300 300" className="w-64 h-64 md:w-80 md:h-80 animate-spin-slow">
          <style>{`
            @keyframes orbit1 { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
            @keyframes orbit2 { from { transform: rotate(0deg); } to { transform: rotate(-360deg); } }
            .orbit-path { fill: none; stroke: #cbd5e1; stroke-width: 1; }
            .electron-group-1 { animation: orbit1 8s linear infinite; transform-origin: 150px 150px; }
            .electron-group-2 { animation: orbit2 12s linear infinite; transform-origin: 150px 150px; }
          `}</style>

          <circle cx="150" cy="150" r="130" className="orbit-path" />
          <circle cx="150" cy="150" r="90" className="orbit-path" />

          <g transform="translate(150, 150)">
            <circle r="25" fill="#334155" className="drop-shadow-lg" />
            <text x="0" y="5" textAnchor="middle" fill="white" fontSize="24" fontWeight="bold" fontFamily="Arial">+</text>
            <text x="0" y="45" textAnchor="middle" fill="#334155" fontSize="10" fontWeight="bold" fontFamily="Arial" style={{ textTransform: 'uppercase' }}>NUCLEUS</text>
          </g>

          <g className="electron-group-1">
            <circle cx="150" cy="60" r="6" fill="#2563eb" />
            <circle cx="150" cy="240" r="6" fill="#2563eb" />
          </g>

          <g className="electron-group-2">
            <circle cx="280" cy="150" r="6" fill="#2563eb" />
            <circle cx="20" cy="150" r="6" fill="#2563eb" />
            <circle cx="150" cy="20" r="6" fill="#2563eb" />
          </g>
        </svg>
      </div>
    );

    const ElectricFieldDiagram = () => (
      <div className="flex flex-col items-center my-8 p-6 bg-white rounded-lg shadow-sm border border-slate-200">
        <h4 className="font-bold text-slate-700 mb-4 flex items-center gap-2 uppercase text-sm tracking-wider"><ZapIcon size={16} className="text-yellow-500"/> Behavior in Electric Field</h4>
        <svg viewBox="0 0 400 200" className="w-full max-w-lg bg-slate-50 rounded border border-slate-200">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
            </marker>
          </defs>

          <rect x="50" y="20" width="300" height="8" fill="#ef4444" />
          <text x="200" y="15" textAnchor="middle" fill="#ef4444" fontWeight="bold" fontSize="10" fontFamily="sans-serif">POSITIVE PLATE (+)</text>

          <rect x="50" y="170" width="300" height="8" fill="#3b82f6" />
          <text x="200" y="195" textAnchor="middle" fill="#3b82f6" fontWeight="bold" fontSize="10" fontFamily="sans-serif">NEGATIVE PLATE (-)</text>

          <path d="M 20 100 Q 200 100 300 30" fill="none" stroke="#3b82f6" strokeWidth="2" markerEnd="url(#arrow)" strokeDasharray="4,2" />
          <circle cx="300" cy="30" r="4" fill="#3b82f6" />
          <text x="310" y="30" fill="#3b82f6" fontSize="10" fontWeight="bold" fontFamily="sans-serif">Electron</text>

          <path d="M 20 100 Q 250 100 300 160" fill="none" stroke="#ef4444" strokeWidth="2" markerEnd="url(#arrow)" />
          <circle cx="300" cy="160" r="5" fill="#ef4444" />
          <text x="310" y="160" fill="#ef4444" fontSize="10" fontWeight="bold" fontFamily="sans-serif">Proton</text>

          <path d="M 20 100 L 350 100" fill="none" stroke="#10b981" strokeWidth="2" strokeDasharray="8,4" markerEnd="url(#arrow)" />
          <circle cx="350" cy="100" r="5" fill="#10b981" />
          <text x="360" y="105" fill="#10b981" fontSize="10" fontWeight="bold" fontFamily="sans-serif">Neutron</text>
        </svg>
      </div>
    );

    const OrbitalShapesDiagram = () => (
      <div className="flex flex-wrap justify-center gap-8 my-8">
        <div className="text-center bg-white p-6 rounded-lg shadow-sm border border-slate-200 hover:shadow-md transition">
          <svg viewBox="0 0 100 100" className="w-32 h-32 mx-auto">
            <circle cx="50" cy="50" r="40" fill="url(#grad1)" />
            <defs>
              <radialGradient id="grad1" cx="30%" cy="30%" r="70%">
                <stop offset="0%" stopColor="#fff" stopOpacity="1" />
                <stop offset="100%" stopColor="#3b82f6" stopOpacity="1" />
              </radialGradient>
            </defs>
          </svg>
          <p className="font-bold text-slate-700 mt-4 text-lg header-font">S-ORBITAL</p>
          <p className="text-slate-500 text-xs uppercase tracking-wide">Spherical</p>
        </div>
        <div className="text-center bg-white p-6 rounded-lg shadow-sm border border-slate-200 hover:shadow-md transition">
          <svg viewBox="0 0 100 100" className="w-32 h-32 mx-auto">
            <path d="M 50 50 C 50 50 10 10 10 50 C 10 90 50 50 50 50 C 50 50 90 10 90 50 C 90 90 50 50 50 50" fill="url(#grad2)" />
            <defs>
              <radialGradient id="grad2" cx="50%" cy="50%" r="50%">
                <stop offset="0%" stopColor="#fff" stopOpacity="1" />
                <stop offset="100%" stopColor="#6366f1" stopOpacity="1" />
              </radialGradient>
            </defs>
          </svg>
          <p className="font-bold text-slate-700 mt-4 text-lg header-font">P-ORBITAL</p>
          <p className="text-slate-500 text-xs uppercase tracking-wide">Dumbbell</p>
        </div>
      </div>
    );

    const IsotopesDiagram = () => (
      <div className="flex flex-col items-center my-8 p-6 bg-white rounded-lg shadow-sm border border-slate-200">
        <h4 className="font-bold text-slate-700 mb-6 flex items-center gap-2 uppercase text-sm tracking-wider">Isotopes of Hydrogen</h4>
        <div className="flex flex-wrap justify-center gap-8 md:gap-16">
          <div className="text-center">
            <svg width="100" height="100" viewBox="0 0 100 100">
              <circle cx="50" cy="50" r="40" fill="none" stroke="#cbd5e1" strokeWidth="1" strokeDasharray="4"/>
              <circle cx="50" cy="10" r="4" fill="#3b82f6" />
              <circle cx="50" cy="50" r="12" fill="#ef4444" />
              <text x="50" y="54" textAnchor="middle" fill="white" fontSize="10" fontWeight="bold">1p</text>
            </svg>
            <p className="font-bold text-slate-700 mt-2 text-sm">Protium</p>
            <p className="text-slate-500 text-xs">1H</p>
          </div>

          <div className="text-center">
            <svg width="100" height="100" viewBox="0 0 100 100">
              <circle cx="50" cy="50" r="40" fill="none" stroke="#cbd5e1" strokeWidth="1" strokeDasharray="4"/>
              <circle cx="50" cy="10" r="4" fill="#3b82f6" />
              <g transform="translate(50,50)">
                <circle cx="-6" cy="0" r="12" fill="#ef4444" />
                <circle cx="6" cy="0" r="12" fill="#10b981" />
                <text x="-6" y="4" textAnchor="middle" fill="white" fontSize="10" fontWeight="bold">p</text>
                <text x="6" y="4" textAnchor="middle" fill="white" fontSize="10" fontWeight="bold">n</text>
              </g>
            </svg>
            <p className="font-bold text-slate-700 mt-2 text-sm">Deuterium</p>
            <p className="text-slate-500 text-xs">2H</p>
          </div>

          <div className="text-center">
            <svg width="100" height="100" viewBox="0 0 100 100">
              <circle cx="50" cy="50" r="40" fill="none" stroke="#cbd5e1" strokeWidth="1" strokeDasharray="4"/>
              <circle cx="50" cy="10" r="4" fill="#3b82f6" />
              <g transform="translate(50,50)">
                <circle cx="0" cy="-8" r="10" fill="#ef4444" />
                <circle cx="-8" cy="6" r="10" fill="#10b981" />
                <circle cx="8" cy="6" r="10" fill="#10b981" />
                <text x="0" y="-5" textAnchor="middle" fill="white" fontSize="8" fontWeight="bold">p</text>
                <text x="-8" y="9" textAnchor="middle" fill="white" fontSize="8" fontWeight="bold">n</text>
                <text x="8" y="9" textAnchor="middle" fill="white" fontSize="8" fontWeight="bold">n</text>
              </g>
            </svg>
            <p className="font-bold text-slate-700 mt-2 text-sm">Tritium</p>
            <p className="text-slate-500 text-xs">3H</p>
          </div>
        </div>
      </div>
    );

    const TrendGraph = () => (
      <div className="bg-white p-6 mt-6 rounded-lg shadow-sm border border-slate-200">
        <h4 className="font-bold text-slate-700 mb-4 text-center text-sm uppercase tracking-wide">Trend Across Period 2 & 3</h4>
        <div className="relative w-full h-48 bg-slate-50 rounded border border-slate-100 p-2">
          <svg viewBox="0 0 300 150" className="w-full h-full">
            <line x1="20" y1="130" x2="280" y2="130" stroke="#cbd5e1" strokeWidth="1" />
            <line x1="20" y1="20" x2="20" y2="130" stroke="#cbd5e1" strokeWidth="1" />

            <polyline
              points="20,110 50,40 80,90 110,50 140,40 170,20 200,30 230,10"
              fill="none"
              stroke="#2563eb"
              strokeWidth="2"
              strokeLinecap="square"
              strokeLinejoin="round"
            />

            <text x="150" y="145" textAnchor="middle" fontSize="8" fill="#64748b" fontFamily="sans-serif" fontWeight="bold" style={{ textTransform: 'uppercase' }}>Atomic Number (Z) ‚Üí</text>
            <text x="10" y="75" textAnchor="middle" fontSize="8" fill="#64748b" transform="rotate(-90 10,75)" fontFamily="sans-serif" fontWeight="bold" style={{ textTransform: 'uppercase' }}>Ionisation Energy</text>

            <g>
              <circle cx="50" cy="40" r="3" fill="#ef4444" />
              <text x="50" y="30" fontSize="8" fill="#ef4444" textAnchor="middle" fontWeight="bold" fontFamily="sans-serif">Be</text>
            </g>
            <g>
              <circle cx="80" cy="90" r="3" fill="#ef4444" />
              <text x="80" y="105" fontSize="8" fill="#ef4444" textAnchor="middle" fontWeight="bold" fontFamily="sans-serif">B</text>
            </g>
          </svg>
        </div>
      </div>
    );

    const contentData = {
      particles: {
        title: 'Atomic Structure & Subatomic Particles',
        points: [
          'All matter is composed of atoms (smallest part taking place in chemical reactions).',
          <>Atoms are mostly <span className="key-bold">empty space</span> around a small, dense <span className="key-circle">nucleus</span> containing <span className="key-bold">protons</span> and <span className="key-bold">neutrons</span>.</>,
          'Nucleus has an overall positive charge.',
          'Protons = Positive (+). Neutrons = Neutral (0).',
          <>Negatively charged <span className="key-bold">electrons</span> are arranged in shells (energy levels) surrounding the nucleus.</>,
          <>Mass is concentrated in the <span className="key-bold">nucleus</span>.</>,
          'Held together by electrostatic attraction between +ve nucleus and -ve electrons.'
        ],
        table: [
          { p: 'Proton', c: '+1', m: '1' },
          { p: 'Neutron', c: '0', m: '1' },
          { p: 'Electron', c: '-1', m: <Fraction num="1" den="1836" /> }
        ],
        fieldPoints: [
          <>Protons, neutrons, electrons travel at same velocity through electric field.</>,
          <><span className="key-bold text-blue-600">Electron</span>: Deflected <span className="key-underline">strongly</span> to positive plate (light mass, -ve charge).</>,
          <><span className="key-bold text-red-600">Proton</span>: Deflected <span className="key-italic">slightly</span> to negative plate (heavy mass, +ve charge).</>,
          <><span className="key-bold text-green-600">Neutron</span>: No deflection (neutral).</>
        ],
        calculations: [
          <><span className="key-bold">Atomic Number (Z)</span> = Proton Number (number of protons).</>,
          'Neutral Atom: Protons = Electrons.',
          <><span className="key-bold">Mass Number (A)</span> = Nucleon Number (Protons + Neutrons).</>,
          'Neutrons = A - Z.',
          'Ions: Atoms gain/lose electrons.',
          <><span className="key-bold">Cation (+)</span>: Lose electrons (p &gt; e).</>,
          <><span className="key-bold">Anion (-)</span>: Gain electrons (e &gt; p).</>
        ],
        quiz: [
          { question: 'Where is the mass of an atom concentrated?', options: [{text: 'Shells', correct: false}, {text: 'Nucleus', correct: true}, {text: 'Empty Space', correct: false}], correct: 1 },
          { question: 'What is the relative mass of an electron?', options: [{text: '1', correct: false}, {text: '1/1836', correct: true}, {text: '0', correct: false}], correct: 1 },
          { question: 'Which particle is deflected most strongly in an electric field?', options: [{text: 'Proton', correct: false}, {text: 'Neutron', correct: false}, {text: 'Electron', correct: true}], correct: 2 },
          { question: 'What is the Atomic Number (Z)?', options: [{text: 'Number of Neutrons', correct: false}, {text: 'Number of Protons', correct: true}, {text: 'Protons + Neutrons', correct: false}], correct: 1 },
          { question: 'How do you calculate neutrons?', options: [{text: 'A - Z', correct: true}, {text: 'A + Z', correct: false}, {text: 'Z - A', correct: false}], correct: 0 },
          { question: 'What charge does a Nucleus have?', options: [{text: 'Negative', correct: false}, {text: 'Neutral', correct: false}, {text: 'Positive', correct: true}], correct: 2 },
          { question: 'If an atom loses 2 electrons, it becomes...', options: [{text: '2- Anion', correct: false}, {text: '2+ Cation', correct: true}, {text: 'Neutral', correct: false}], correct: 1 },
          { question: 'Protons and Neutrons are collectively known as...', options: [{text: 'Nucleons', correct: true}, {text: 'Isotopes', correct: false}, {text: 'Ions', correct: false}], correct: 0 },
          { question: 'Why do neutrons pass straight through an electric field?', options: [{text: 'They are heavy', correct: false}, {text: 'They are neutral', correct: true}, {text: 'They move too fast', correct: false}], correct: 1 },
          { question: 'Mg (Z=12) forms Mg2+. How many electrons?', options: [{text: '12', correct: false}, {text: '14', correct: false}, {text: '10', correct: true}], correct: 2 },
        ]
      },
      isotopes: {
        title: 'Isotopes',
        points: [
          <>Isotopes: Atoms of the <span className="key-underline">same element</span> with same number of protons and electrons but <span className="key-circle">different number of neutrons</span>.</>,
          'Notation: Chemical Symbol followed by dash and mass number (e.g., Carbon-12, Carbon-14).',
          'Isotopes have same Chemical Symbol and Atomic Number (Z).',
          'Different Mass/Nucleon Number (A).'
        ],
        props: [
          <><span className="key-float">Chemical Properties</span>: <span className="key-bold">SIMILAR</span>. Because they have same electron configuration (valence electrons determine reactivity).</>,
          <><span className="key-float">Physical Properties</span>: <span className="key-bold">DIFFERENT</span>. Because they have different masses (affecting density, diffusion rate, etc.).</>
        ],
        quiz: [
          { question: 'Isotopes have different...', options: [{text: 'Protons', correct: false}, {text: 'Neutrons', correct: true}, {text: 'Electrons', correct: false}], correct: 1 },
          { question: 'Do isotopes have the same chemical properties?', options: [{text: 'Yes', correct: true}, {text: 'No', correct: false}, {text: 'Sometimes', correct: false}], correct: 0 },
          { question: 'Why are chemical properties the same?', options: [{text: 'Same Mass', correct: false}, {text: 'Same Electron Config', correct: true}, {text: 'Same Neutrons', correct: false}], correct: 1 },
          { question: 'Chlorine-35 and Chlorine-37 differ in...', options: [{text: 'Atomic Number', correct: false}, {text: 'Nucleon Number', correct: true}, {text: 'Charge', correct: false}], correct: 1 },
          { question: 'Which property is different in isotopes?', options: [{text: 'Reactivity', correct: false}, {text: 'Density', correct: true}, {text: 'Bonding', correct: false}], correct: 1 },
          { question: 'Hydrogen-3 (Tritium) has how many neutrons? (Z=1)', options: [{text: '1', correct: false}, {text: '2', correct: true}, {text: '3', correct: false}], correct: 1 },
          { question: 'Neutrons affect chemical bonding.', options: [{text: 'True', correct: false}, {text: 'False', correct: true}], correct: 1 },
          { question: 'Mass spectrometry relies on differences in...', options: [{text: 'Charge only', correct: false}, {text: 'Mass', correct: true}, {text: 'Color', correct: false}], correct: 1 },
          { question: 'Carbon-14 has how many protons? (C is element 6)', options: [{text: '6', correct: true}, {text: '8', correct: false}, {text: '14', correct: false}], correct: 0 },
          { question: 'Which subatomic particle is the same in all isotopes of an element?', options: [{text: 'Neutron', correct: false}, {text: 'Proton', correct: true}, {text: 'Nucleon', correct: false}], correct: 1 },
        ]
      },
      electrons: {
        title: 'Electronic Structure & Orbitals',
        shells: [
          'Principal Quantum Shells (n) number energy levels.',
          'Lower n = Closer to nucleus = Lower energy.',
          'Max electrons: n=1 (2), n=2 (8), n=3 (18), n=4 (32).',
          <>Sub-shells: <span className="key-bold">s, p, d, f</span>.</>,
          'Energy increases: s < p < d < f.'
        ],
        orbitals: [
          'Sub-shells contain orbitals (regions where electrons are found).',
          'Each orbital holds MAX 2 electrons.',
          's-subshell: 1 orbital (2e). Shape: Spherical.',
          'p-subshell: 3 orbitals (6e). Shape: Dumbbell (px, py, pz).',
          'd-subshell: 5 orbitals (10e).',
          'f-subshell: 7 orbitals (14e).'
        ],
        config: [
          'Ground State: Most stable, lowest energy.',
          <>Filling Order: 1s <span className="font-bold text-green-600">‚Üí</span> 2s <span className="font-bold text-green-600">‚Üí</span> 2p <span className="font-bold text-green-600">‚Üí</span> 3s <span className="font-bold text-green-600">‚Üí</span> 3p <span className="font-bold text-green-600">‚Üí</span> 4s <span className="font-bold text-green-600">‚Üí</span> 3d <span className="font-bold text-green-600">‚Üí</span> 4p</>,
          <><span className="key-circle text-red-500">Important</span>: 4s fills before 3d (lower energy), BUT written before 3d.</>,
          'Spin: Electrons in same orbital have opposite spins (up/down) to minimize repulsion (Spin-pair repulsion).',
          "Hund's Rule: Electrons occupy separate orbitals in same sub-shell first with same spin before pairing.",
          'Free Radical: Species with one or more unpaired electron (e.g., Cl‚Ä¢).'
        ],
        exceptions: [
          <><span className="key-bold">Chromium (Cr)</span>: [Ar] 3d<Power base="5" exp="" /> 4s<Power base="1" exp="" /> (Half-full d-subshell is stable).</>,
          <><span className="key-bold">Copper (Cu)</span>: [Ar] 3d<Power base="10" exp="" /> 4s<Power base="1" exp="" /> (Full d-subshell is stable).</>,
          'Transition Metal Ions: Remove 4s electrons BEFORE 3d.'
        ],
        quiz: [
          { question: 'Max electrons in n=3 shell?', options: [{text: '8', correct: false}, {text: '18', correct: true}, {text: '32', correct: false}], correct: 1 },
          { question: 'Shape of s-orbital?', options: [{text: 'Dumbbell', correct: false}, {text: 'Spherical', correct: true}, {text: 'Square', correct: false}], correct: 1 },
          { question: 'Which fills first?', options: [{text: '3d', correct: false}, {text: '4s', correct: true}, {text: '4p', correct: false}], correct: 1 },
          { question: 'Max electrons in p-subshell?', options: [{text: '2', correct: false}, {text: '6', correct: true}, {text: '10', correct: false}], correct: 1 },
          { question: 'Electronic config of K (19)?', options: [{text: '[Ar] 3d1', correct: false}, {text: '[Ar] 4s1', correct: true}, {text: '1s2...3p6', correct: false}], correct: 1 },
          { question: 'What represents electron spin?', options: [{text: 'Color', correct: false}, {text: 'Direction (Arrow)', correct: true}, {text: 'Size', correct: false}], correct: 1 },
          { question: 'Why do electrons pair up?', options: [{text: 'They like each other', correct: false}, {text: 'No empty orbitals left', correct: true}, {text: 'To increase energy', correct: false}], correct: 1 },
          { question: 'Exception for Cr configuration is due to...', options: [{text: 'Half-full d-subshell stability', correct: true}, {text: 'Full s-subshell', correct: false}, {text: 'Nuclear charge', correct: false}], correct: 0 },
          { question: 'When forming Fe2+, electrons are removed from...', options: [{text: '3d', correct: false}, {text: '4s', correct: true}, {text: '3p', correct: false}], correct: 1 },
          { question: 'Free radicals have...', options: [{text: 'Paired electrons', correct: false}, {text: 'Unpaired electrons', correct: true}, {text: 'No electrons', correct: false}], correct: 1 },
        ]
      },
      radius: {
        title: 'Atomic & Ionic Radius',
        atomic: [
          'Atomic Radius: Half the distance between nuclei of two covalently bonded atoms.',
          <><span className="key-bold">Across Period</span>: DECREASES.</>,
          'Reason: Nuclear charge increases, shielding stays same, electrons pulled closer.',
          <><span className="key-bold">Down Group</span>: INCREASES.</>,
          'Reason: Number of shells increases, shielding increases (inner shells repel outer), weakens pull.'
        ],
        ionic: [
          'Ionic Radius: Measure of ion size.',
          <><span className="key-bold">Positive Ion (Cation)</span>: SMALLER than atom.</>,
          'Reason: Lose shell, same nuclear charge pulls fewer electrons strongly.',
          <><span className="key-bold">Negative Ion (Anion)</span>: LARGER than atom.</>,
          'Reason: Gain electrons, more repulsion between electrons, cloud expands.',
          'Isoelectronic Series (same electrons): Radius decreases as nuclear charge increases (more protons pull same electrons tighter).'
        ],
        quiz: [
          { question: 'Atomic radius across a period...', options: [{text: 'Increases', correct: false}, {text: 'Decreases', correct: true}, {text: 'Stays same', correct: false}], correct: 1 },
          { question: 'Why does radius increase down a group?', options: [{text: 'More Shells', correct: true}, {text: 'More Protons', correct: false}, {text: 'Less Shielding', correct: false}], correct: 0 },
          { question: 'A Cation is _____ than its atom.', options: [{text: 'Larger', correct: false}, {text: 'Smaller', correct: true}, {text: 'Same size', correct: false}], correct: 1 },
          { question: 'An Anion is _____ than its atom.', options: [{text: 'Larger', correct: true}, {text: 'Smaller', correct: false}, {text: 'Same size', correct: false}], correct: 0 },
          { question: 'Why do anions get bigger?', options: [{text: 'Less protons', correct: false}, {text: 'Electron repulsion', correct: true}, {text: 'Less shells', correct: false}], correct: 1 },
          { question: 'Which is largest? Na, Mg, Al', options: [{text: 'Na', correct: true}, {text: 'Mg', correct: false}, {text: 'Al', correct: false}], correct: 0 },
          { question: 'Which is smallest? Li, Na, K', options: [{text: 'Li', correct: true}, {text: 'Na', correct: false}, {text: 'K', correct: false}], correct: 0 },
          { question: 'Effect of shielding on radius?', options: [{text: 'Decreases it', correct: false}, {text: 'Increases it', correct: true}, {text: 'No effect', correct: false}], correct: 1 },
          { question: 'Isoelectronic ions have same...', options: [{text: 'Protons', correct: false}, {text: 'Electrons', correct: true}, {text: 'Neutrons', correct: false}], correct: 1 },
          { question: 'Radius trend depends on...', options: [{text: 'Nuclear charge & Shells', correct: true}, {text: 'Mass only', correct: false}, {text: 'Density', correct: false}], correct: 0 },
        ]
      },
      ionization: {
        title: 'Ionization Energy (IE)',
        definition: [
          <><span className="key-bold">1st IE</span>: Energy required to remove 1 mole of electrons from 1 mole of <span className="key-italic">gaseous</span> atoms to form 1 mole of <span className="key-italic">gaseous</span> 1+ ions.</>,
          <div className="font-mono text-sm my-2 text-center bg-slate-100 p-2 rounded border border-slate-200">Ca(g) ‚Üí Ca<sup className="text-xs">+</sup>(g) + e<sup className="text-xs">-</sup></div>,
          'Conditions: 298 K, 101 kPa.',
          'Always Endothermic (+ve value). Need energy to overcome attraction.'
        ],
        factors: [
          <><span className="key-bold">Nuclear Charge</span>: More protons = Stronger attraction = Higher IE.</>,
          <><span className="key-bold">Distance</span>: Further from nucleus = Weaker attraction = Lower IE.</>,
          <><span className="key-bold">Shielding</span>: Inner electrons repel outer = Weaker attraction = Lower IE.</>,
          <><span className="key-bold">Spin-pair Repulsion</span>: Paired electrons repel each other = Easier to remove.</>
        ],
        trends: [
          <><span className="key-bold">Across Period</span>: INCREASES.</>,
          'Reason: Nuclear charge increases, radius decreases, shielding const.',
          'Exceptions (Dips):',
          <><span className="key-circle">Be ‚Üí B</span>: B electron in 2p (higher energy/further) than Be 2s. Easier to remove.</>,
          <><span className="key-circle">N ‚Üí O</span>: O has paired electron in 2p. Repulsion makes it easier to remove.</>,
          <><span className="key-bold">Down Group</span>: DECREASES.</>,
          'Reason: Radius increases, Shielding increases (outweighs nuclear charge).'
        ],
        successive: [
          'Successive IE always INCREASES (removing -ve from increasingly +ve ion).',
          'Large JUMP = Change of Shell (closer to nucleus).',
          'Used to predict Group number (Jump after x electrons = Group x).'
        ],
        quiz: [
          { question: 'First IE equation includes which state symbol?', options: [{text: '(s)', correct: false}, {text: '(l)', correct: false}, {text: '(g)', correct: true}], correct: 2 },
          { question: 'IE values are always...', options: [{text: 'Positive', correct: true}, {text: 'Negative', correct: false}, {text: 'Zero', correct: false}], correct: 0 },
          { question: 'General trend across Period 3?', options: [{text: 'Decrease', correct: false}, {text: 'Increase', correct: true}, {text: 'Constant', correct: false}], correct: 1 },
          { question: 'Why does IE drop from N to O?', options: [{text: 'Spin-pair repulsion', correct: true}, {text: 'Shielding', correct: false}, {text: 'Distance', correct: false}], correct: 0 },
          { question: 'Why does IE drop from Be to B?', options: [{text: 'Change from 2s to 2p', correct: true}, {text: 'Less protons', correct: false}, {text: 'More shielding', correct: false}], correct: 0 },
          { question: 'Large jump after 2nd electron means...', options: [{text: 'Group 1', correct: false}, {text: 'Group 2', correct: true}, {text: 'Group 3', correct: false}], correct: 1 },
          { question: 'Shielding effect comes from...', options: [{text: 'Outer electrons', correct: false}, {text: 'Inner electrons', correct: true}, {text: 'Protons', correct: false}], correct: 1 },
          { question: 'High nuclear charge leads to...', options: [{text: 'Lower IE', correct: false}, {text: 'Higher IE', correct: true}, {text: 'No change', correct: false}], correct: 1 },
          { question: 'Second IE is always ____ than First IE.', options: [{text: 'Lower', correct: false}, {text: 'Higher', correct: true}, {text: 'Same', correct: false}], correct: 1 },
          { question: 'Which has highest IE in Period 2?', options: [{text: 'Li', correct: false}, {text: 'Ne', correct: true}, {text: 'F', correct: false}], correct: 1 },
        ]
      }
    };

    const MindMap = ({ onSelect }) => (
      <div className="flex flex-col items-center justify-center min-h-[80vh] animate-fade-in px-4">
        <div className="mb-12 text-center">
          <h1 className="text-5xl md:text-8xl font-bold text-slate-800 mb-4 header-font tracking-tighter uppercase">Atomic Structure</h1>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-5xl">
          <MapButton onClick={() => onSelect('particles')} color="border-l-8 border-red-500" icon={<AtomIcon size={32}/>} title="Particles & Structure" sub="Protons, Neutrons, Electrons" delay="0s" />
          <MapButton onClick={() => onSelect('isotopes')} color="border-l-8 border-yellow-500" icon={<SearchIcon size={32}/>} title="Isotopes" sub="Physical vs Chemical Props" delay="0.1s" />
          <MapButton onClick={() => onSelect('electrons')} color="border-l-8 border-blue-500" icon={<ZapIcon size={32}/>} title="Electrons & Orbitals" sub="s, p, d, f Config" delay="0.2s" />
          <MapButton onClick={() => onSelect('radius')} color="border-l-8 border-purple-500" icon={<CircleIcon size={32}/>} title="Atomic Radius" sub="Periodic Trends" delay="0.3s" />
          <MapButton onClick={() => onSelect('ionization')} color="border-l-8 border-green-500" icon={<ZapIcon size={32}/>} title="Ionization Energy" sub="Trends & Factors" delay="0.4s" />
        </div>

        <div className="mt-12 text-slate-400 text-xs uppercase tracking-widest">Select a module to begin</div>
      </div>
    );

    const MapButton = ({ onClick, color, icon, title, sub, delay }) => (
      <button
        onClick={onClick}
        style={{ animationDelay: delay }}
        className={`bg-white p-6 rounded shadow-sm hover:shadow-lg transform hover:-translate-y-1 transition-all duration-300 text-left relative overflow-hidden group animate-fade-in-up w-full border border-slate-200 ${color}`}
      >
        <div className="flex items-start justify-between">
          <div>
            <div className="text-slate-800 mb-2">{icon}</div>
            <h3 className="text-xl md:text-2xl font-bold mb-1 leading-tight header-font uppercase text-slate-800">{title}</h3>
            <p className="text-slate-500 text-sm font-medium">{sub}</p>
          </div>
          <div className="opacity-0 group-hover:opacity-100 transition-opacity transform translate-x-4 group-hover:translate-x-0 text-slate-400">
            <ArrowRightIcon size={24} />
          </div>
        </div>
      </button>
    );

    const App = () => {
      const [activeSection, setActiveSection] = useState('mindmap');

      const renderSection = () => {
        switch (activeSection) {
          case 'particles': return (
            <div className="animate-fade-in-up">
              <SectionTitle>Particles & Atom Structure</SectionTitle>
              <AtomDiagram />

              <SubHeading>1. Structure of Atom</SubHeading>
              <ModelViewer label="Structure of Atom" docKey="structureAtom" />
              <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200 mb-6">
                <ul>{contentData.particles.points.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <SubHeading>2. Subatomic Particles</SubHeading>
              <div className="overflow-x-auto my-6 rounded-lg shadow border border-slate-200">
                <table className="w-full text-left border-collapse bg-white">
                  <thead>
                    <tr className="bg-slate-800 text-white header-font">
                      <th className="p-4 font-normal tracking-wide">PARTICLE</th>
                      <th className="p-4 font-normal tracking-wide">RELATIVE CHARGE</th>
                      <th className="p-4 font-normal tracking-wide">RELATIVE MASS</th>
                    </tr>
                  </thead>
                  <tbody>
                    {contentData.particles.table.map((row, i) => (
                      <tr key={i} className="border-b border-slate-100 hover:bg-slate-50 last:border-0 transition-colors">
                        <td className="p-4 font-bold text-slate-700">{row.p}</td>
                        <td className="p-4 text-slate-600 font-mono">{row.c}</td>
                        <td className="p-4 text-slate-600">{row.m}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>

              <ElectricFieldDiagram />
              <ModelViewer label="Behavior in Electric Field" docKey="electricField" />
              <div className="bg-blue-50 p-6 rounded-lg border-l-4 border-blue-500 mb-8">
                <ul className="space-y-2">{contentData.particles.fieldPoints.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <SubHeading>3. Calculations & Ions</SubHeading>
              <div className="bg-slate-50 p-6 rounded-lg border border-slate-200 mb-8">
                <ul className="space-y-2">{contentData.particles.calculations.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <Quiz questions={contentData.particles.quiz} />
            </div>
          );
          case 'isotopes': return (
            <div className="animate-fade-in-up">
              <SectionTitle>Isotopes</SectionTitle>

              <div className="grid md:grid-cols-2 gap-6 mb-8">
                <div className="bg-white p-6 rounded-lg shadow-sm border-t-4 border-blue-600 hover:shadow-md transition">
                  <h3 className="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2 header-font"><SearchIcon size={20}/> DEFINITION</h3>
                  <ul>{contentData.isotopes.points.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
                </div>
                <div className="bg-white p-6 rounded-lg shadow-sm border-t-4 border-indigo-600 hover:shadow-md transition">
                  <h3 className="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2 header-font"><ZapIcon size={20}/> PROPERTIES</h3>
                  <ul>{contentData.isotopes.props.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
                </div>
              </div>

              <IsotopesDiagram />

              <Quiz questions={contentData.isotopes.quiz} />
            </div>
          );
          case 'electrons': return (
            <div className="animate-fade-in-up">
              <SectionTitle>Electronic Structure</SectionTitle>

              <SubHeading>1. Shells & Sub-shells</SubHeading>
              <ModelViewer label="Shells & Sub-shells" docKey="shellsSubshells" />
              <div className="bg-white p-6 rounded-lg shadow-sm mb-6 border border-slate-200">
                <ul>{contentData.electrons.shells.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <SubHeading>2. Orbitals</SubHeading>
              <div className="grid gap-3 md:grid-cols-2 lg:grid-cols-3 mb-4">
                <ModelViewer label="Orbitals Overview" docKey="orbitalsHierarchy" className="my-0" />
                <ModelViewer label="Orbital Shapes" docKey="orbitalsShapes" className="my-0" />
                <ModelViewer label="s-Orbital Expansion" docKey="orbitalsExpansion" className="my-0" />
              </div>
              <OrbitalShapesDiagram />
              <div className="bg-white p-6 rounded-lg shadow-sm mb-6 border border-slate-200">
                <ul>{contentData.electrons.orbitals.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <SubHeading>3. Configuration & Filling</SubHeading>
              <div className="grid md:grid-cols-2 gap-3 mb-4">
                <ModelViewer label="Filling Order" docKey="fillingOrder" className="my-0" />
                <ModelViewer label="Ground State" docKey="groundState" className="my-0" />
                <ModelViewer label="Hund's Rule" docKey="hundRule" className="my-0" />
                <ModelViewer label="Spin & Pairing" docKey="spin" className="my-0" />
              </div>
              <div className="bg-slate-50 p-6 rounded-lg shadow-inner border border-slate-200 mb-6">
                <ul>{contentData.electrons.config.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <SubHeading>4. Exceptions (Review Twice!)</SubHeading>
              <div className="bg-red-50 p-6 rounded-lg border-l-4 border-red-500 mb-8">
                <div className="flex items-center gap-2 mb-4 text-red-800 font-bold uppercase tracking-wider text-sm">
                  <span className="text-lg">‚ö†Ô∏è</span> Critical Exam Point
                </div>
                <ul>{contentData.electrons.exceptions.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <Quiz questions={contentData.electrons.quiz} />
            </div>
          );
          case 'radius': return (
            <div className="animate-fade-in-up">
              <SectionTitle>Atomic & Ionic Radius</SectionTitle>

              <div className="flex justify-center my-8 p-6 bg-white rounded-lg shadow-sm border border-slate-200">
                <svg width="220" height="140">
                  <circle cx="60" cy="70" r="40" fill="#e2e8f0" stroke="#1e293b" strokeWidth="2"/>
                  <circle cx="160" cy="70" r="40" fill="#e2e8f0" stroke="#1e293b" strokeWidth="2"/>
                  <line x1="60" y1="70" x2="160" y2="70" stroke="#ef4444" strokeWidth="2" strokeDasharray="4"/>
                  <text x="110" y="60" textAnchor="middle" fill="#ef4444" fontWeight="bold" fontSize="12" fontFamily="sans-serif">d</text>
                  <text x="110" y="120" textAnchor="middle" fill="#1e293b" fontWeight="bold" fontFamily="sans-serif" fontSize="12">RADIUS = d/2</text>
                </svg>
              </div>

              <div className="grid md:grid-cols-2 gap-6 mb-8">
                <div className="bg-orange-50 p-6 rounded-lg border border-orange-200">
                  <h3 className="text-xl font-bold text-orange-900 mb-4 header-font">ATOMIC RADIUS</h3>
                  <ul>{contentData.radius.atomic.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
                </div>
                <div className="bg-indigo-50 p-6 rounded-lg border border-indigo-200">
                  <h3 className="text-xl font-bold text-indigo-900 mb-4 header-font">IONIC RADIUS</h3>
                  <ul>{contentData.radius.ionic.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
                </div>
              </div>

              <div className="flex justify-center gap-8 items-end mt-8 p-8 bg-white rounded-lg shadow-md border border-slate-200 mb-8">
                <div className="text-center group">
                  <div className="w-20 h-20 rounded-full bg-slate-300 mx-auto mb-3 shadow-inner"></div>
                  <p className="font-bold text-slate-600 text-sm uppercase">Atom</p>
                </div>
                <div className="text-center group">
                  <div className="w-12 h-12 rounded-full bg-red-100 border-2 border-red-500 mx-auto mb-3 shadow-sm flex items-center justify-center font-bold text-red-500">+</div>
                  <p className="text-red-700 font-bold text-sm uppercase">Cation</p>
                  <p className="text-[10px] text-white bg-red-500 px-2 py-0.5 rounded mt-1 uppercase">Smaller</p>
                </div>
                <div className="text-center group">
                  <div className="w-24 h-24 rounded-full bg-blue-100 border-2 border-blue-500 mx-auto mb-3 shadow-sm flex items-center justify-center font-bold text-blue-500 text-2xl">-</div>
                  <p className="text-blue-700 font-bold text-sm uppercase">Anion</p>
                  <p className="text-[10px] text-white bg-blue-500 px-2 py-0.5 rounded mt-1 uppercase">Larger</p>
                </div>
              </div>

              <Quiz questions={contentData.radius.quiz} />
            </div>
          );
          case 'ionization': return (
            <div className="animate-fade-in-up">
              <SectionTitle>Ionization Energy</SectionTitle>

              <SubHeading>1. Definition</SubHeading>
              <div className="bg-white p-6 rounded-lg border-l-4 border-yellow-400 shadow-sm mb-6">
                <ul>{contentData.ionization.definition.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <SubHeading>2. Factors Affecting IE</SubHeading>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                {contentData.ionization.factors.map((p, i) => (
                  <div key={i} className="bg-white p-4 rounded-lg shadow-sm border border-slate-200 flex items-center hover:shadow-md transition">
                    <span className="text-lg mr-4 bg-yellow-100 p-2 rounded text-yellow-700">‚ö°</span>
                    <div className="text-slate-700 font-medium">{p}</div>
                  </div>
                ))}
              </div>

              <SubHeading>3. Trends</SubHeading>
              <div className="bg-slate-50 p-6 rounded-lg border border-slate-200 mb-6">
                <ul>{contentData.ionization.trends.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <TrendGraph />

              <SubHeading>4. Successive IE</SubHeading>
              <div className="bg-green-50 p-6 rounded-lg border-l-4 border-green-500 mb-8">
                <ul>{contentData.ionization.successive.map((p, i) => <Point key={i}>{p}</Point>)}</ul>
              </div>

              <Quiz questions={contentData.ionization.quiz} />
            </div>
          );
          default: return <MindMap onSelect={setActiveSection} />;
        }
      };

      return (
        <div className="min-h-screen bg-slate-100 font-sans pb-24 text-slate-800">
          <div className="bg-slate-900 text-white shadow-md p-4 sticky top-0 z-50 flex justify-between items-center border-b border-slate-700">
            <button
              onClick={() => setActiveSection('mindmap')}
              className="text-slate-300 hover:text-white hover:bg-slate-800 px-4 py-2 rounded transition flex items-center gap-2 uppercase font-bold text-sm tracking-widest"
            >
              <CircleIcon size={16} className="fill-slate-300" strokeWidth={1.8} /> <span className="hidden sm:inline">Modules</span>
            </button>
            <div className="w-8"></div>
          </div>

          <div className="max-w-4xl mx-auto p-4 md:p-8">
            {renderSection()}
          </div>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
